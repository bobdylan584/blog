
<!doctype html>
<html lang="zh" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      <link rel="icon" href="../img/logo.png">
      <meta name="generator" content="mkdocs-1.4.2, mkdocs-material-8.5.10">
    
    
      
        <title>4.8 文档解析工具(扩展资料) - EduRAG智慧回答项目V1.0</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.975780f9.min.css">
      
        
        <link rel="stylesheet" href="../assets/stylesheets/palette.2505c338.min.css">
        
      
      

    
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="None" data-md-color-accent="None">
  
    
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#_1" class="md-skip">
          跳转至
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="页眉">
    <a href=".." title="EduRAG智慧回答项目V1.0" class="md-header__button md-logo" aria-label="EduRAG智慧回答项目V1.0" data-md-component="logo">
      
  <img src="../img/logo.png" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            EduRAG智慧回答项目V1.0
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              4.8 文档解析工具(扩展资料)
            
          </span>
        </div>
      </div>
    </div>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="搜索" placeholder="搜索" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="查找">
        
        <button type="reset" class="md-search__icon md-icon" title="清空当前内容" aria-label="清空当前内容" tabindex="-1">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            正在初始化搜索引擎
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


<nav class="md-nav md-nav--primary" aria-label="导航栏" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="EduRAG智慧回答项目V1.0" class="md-nav__button md-logo" aria-label="EduRAG智慧回答项目V1.0" data-md-component="logo">
      
  <img src="../img/logo.png" alt="logo">

    </a>
    EduRAG智慧回答项目V1.0
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_1" type="checkbox" id="__nav_1" >
      
      
      
      
        <label class="md-nav__link" for="__nav_1">
          第一章:项目背景
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="第一章:项目背景" data-md-level="1">
        <label class="md-nav__title" for="__nav_1">
          <span class="md-nav__icon md-icon"></span>
          第一章:项目背景
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9A%E9%A1%B9%E7%9B%AE%E8%83%8C%E6%99%AF/01-RAG%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D.html" class="md-nav__link">
        1.1 项目背景介绍
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_2" type="checkbox" id="__nav_2" >
      
      
      
      
        <label class="md-nav__link" for="__nav_2">
          第二章:项目工具介绍
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="第二章:项目工具介绍" data-md-level="1">
        <label class="md-nav__title" for="__nav_2">
          <span class="md-nav__icon md-icon"></span>
          第二章:项目工具介绍
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%9A%E9%A1%B9%E7%9B%AE%E5%B7%A5%E5%85%B7/01-Ollama%E5%A4%A7%E6%A8%A1%E5%9E%8B%E9%AB%98%E6%95%88%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7.html" class="md-nav__link">
        2.1 Ollama大模型管理工具
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%9A%E9%A1%B9%E7%9B%AE%E5%B7%A5%E5%85%B7/02-LangChain%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.html" class="md-nav__link">
        2.2 LangChain基础知识
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%9A%E9%A1%B9%E7%9B%AE%E5%B7%A5%E5%85%B7/03-Milvus%E5%90%91%E9%87%8F%E6%95%B0%E6%8D%AE%E5%BA%93.html" class="md-nav__link">
        2.3 Mirvus向量数据库
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%9A%E9%A1%B9%E7%9B%AE%E5%B7%A5%E5%85%B7/Milvus%E5%92%8CRedis%E7%9A%84%E5%AE%89%E8%A3%85%28%E6%89%A9%E5%B1%95%E8%B5%84%E6%96%99%29.html" class="md-nav__link">
        2.3 Milvus和Redis的安装(扩展资料)
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_3" type="checkbox" id="__nav_3" >
      
      
      
      
        <label class="md-nav__link" for="__nav_3">
          第三章:基于Mysql数据库构建问答系统
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="第三章:基于Mysql数据库构建问答系统" data-md-level="1">
        <label class="md-nav__title" for="__nav_3">
          <span class="md-nav__icon md-icon"></span>
          第三章:基于Mysql数据库构建问答系统
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%9A%E5%9F%BA%E4%BA%8EMysql%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9E%84%E5%BB%BA%E9%97%AE%E7%AD%94%E7%B3%BB%E7%BB%9F/01.Python%E6%97%A5%E5%BF%97%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%BA%94%E7%94%A8.html" class="md-nav__link">
        3.1 Python日志介绍与应用
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%9A%E5%9F%BA%E4%BA%8EMysql%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9E%84%E5%BB%BA%E9%97%AE%E7%AD%94%E7%B3%BB%E7%BB%9F/02.BM25%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%BA%94%E7%94%A8.html" class="md-nav__link">
        3.2 BM25算法简介与应用
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%9A%E5%9F%BA%E4%BA%8EMysql%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9E%84%E5%BB%BA%E9%97%AE%E7%AD%94%E7%B3%BB%E7%BB%9F/03.Redis%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%80%E4%BB%8B%E4%B8%8E%E4%BD%BF%E7%94%A8.html" class="md-nav__link">
        3.3 Redis数据库简介与使用
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%9A%E5%9F%BA%E4%BA%8EMysql%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9E%84%E5%BB%BA%E9%97%AE%E7%AD%94%E7%B3%BB%E7%BB%9F/04.%E5%9F%BA%E4%BA%8EMysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9E%E7%8E%B0%E9%97%AE%E7%AD%94%E7%B3%BB%E7%BB%9F.html" class="md-nav__link">
        3.4 基于Mysql数据库实现问答系统
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
    
  
  
    
    <li class="md-nav__item md-nav__item--active md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_4" type="checkbox" id="__nav_4" checked>
      
      
      
      
        <label class="md-nav__link" for="__nav_4">
          第四章:基于Milvus数据库构建RAG问答系统
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="第四章:基于Milvus数据库构建RAG问答系统" data-md-level="1">
        <label class="md-nav__title" for="__nav_4">
          <span class="md-nav__icon md-icon"></span>
          第四章:基于Milvus数据库构建RAG问答系统
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="01-%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84%E4%B8%8E%E5%B7%A5%E7%A8%8B%E6%B5%81%E7%A8%8B.html" class="md-nav__link">
        4.1 整体架构与工程流程
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="02-%E5%9F%BA%E7%A1%80%E6%A8%A1%E5%9D%97.html" class="md-nav__link">
        4.2 基础模块
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="03-%E6%96%87%E6%A1%A3%E5%A4%84%E7%90%86%E6%A8%A1%E5%9D%97.html" class="md-nav__link">
        4.3 文档处理模块
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="04-%E5%90%91%E9%87%8F%E5%AD%98%E5%82%A8.html" class="md-nav__link">
        4.4 向量存储
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="05-prompts%E8%AE%BE%E8%AE%A1%E4%B8%8Equery%E6%84%8F%E5%9B%BE%E8%AF%86%E5%88%AB.html" class="md-nav__link">
        4.5 prompts设计与query意图识别
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="06-%E6%A3%80%E7%B4%A2%E7%AD%96%E7%95%A5%E4%B8%8ERAG%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1.html" class="md-nav__link">
        4.6 检索策略与RAG系统设计
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="07-RAG%E7%B3%BB%E7%BB%9F%E8%BF%90%E8%A1%8C.html" class="md-nav__link">
        4.7 RAG系统运行
      </a>
    </li>
  

            
          
            
              
  
  
    
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" data-md-toggle="toc" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          4.8 文档解析工具(扩展资料)
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="%E8%87%AA%E5%AE%9A%E4%B9%89%E6%96%87%E6%A1%A3%E8%A7%A3%E6%9E%90%E5%B7%A5%E5%85%B7%28%E6%89%A9%E5%B1%95%E8%B5%84%E6%96%99%29.html" class="md-nav__link md-nav__link--active">
        4.8 文档解析工具(扩展资料)
      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    学习目标
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#edu_document_loaders" class="md-nav__link">
    文档解析工具 (edu_document_loaders/)
  </a>
  
    <nav class="md-nav" aria-label="文档解析工具 (edu_document_loaders/)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#ocr-edu_ocrpy" class="md-nav__link">
    OCR 引擎核心 (edu_ocr.py)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pdf-edu_pdfloaderpy" class="md-nav__link">
    PDF 文档加载器 (edu_pdfloader.py)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#word-edu_docloaderpy" class="md-nav__link">
    Word 文档加载器 (edu_docloader.py)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#powerpoint-edu_pptloaderpy" class="md-nav__link">
    PowerPoint 文档加载器 (edu_pptloader.py)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#edu_imgloaderpy" class="md-nav__link">
    图像文件加载器 (edu_imgloader.py)
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#edu_text_spliter" class="md-nav__link">
    文本切分工具 (edu_text_spliter/)
  </a>
  
    <nav class="md-nav" aria-label="文本切分工具 (edu_text_spliter/)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#edu_chinese_recursive_text_splitterpy" class="md-nav__link">
    中文递归文本切分器 (edu_chinese_recursive_text_splitter.py)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#edu_model_text_spliterpy" class="md-nav__link">
    基于模型的语义切分器 (edu_model_text_spliter.py)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_3" class="md-nav__link">
    本章总结
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_5" type="checkbox" id="__nav_5" >
      
      
      
      
        <label class="md-nav__link" for="__nav_5">
          第五章:RAG系统评估
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="第五章:RAG系统评估" data-md-level="1">
        <label class="md-nav__title" for="__nav_5">
          <span class="md-nav__icon md-icon"></span>
          第五章:RAG系统评估
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E7%AC%AC%E4%BA%94%E7%AB%A0%EF%BC%9ARAG%E7%B3%BB%E7%BB%9F%E8%AF%84%E4%BC%B0/01-RAG%E7%B3%BB%E7%BB%9F%E8%AF%84%E4%BC%B0%E5%B7%A5%E5%85%B7.html" class="md-nav__link">
        5.1 RAG系统评估工具
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E7%AC%AC%E4%BA%94%E7%AB%A0%EF%BC%9ARAG%E7%B3%BB%E7%BB%9F%E8%AF%84%E4%BC%B0/02-%E5%AE%9E%E7%8E%B0EduRAG%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%AF%84%E4%BC%B0.html" class="md-nav__link">
        5.2 实现EduRAG系统的评估
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E7%AC%AC%E4%BA%94%E7%AB%A0%EF%BC%9ARAG%E7%B3%BB%E7%BB%9F%E8%AF%84%E4%BC%B0/03-RAG%E8%AF%84%E4%BC%B0%E6%95%B0%E6%8D%AE%E9%9B%86%E7%9A%84%E6%9E%84%E9%80%A0%28%E6%89%A9%E5%B1%95%29.html" class="md-nav__link">
        5.3 RAG评估数据集的构造(扩展)
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_6" type="checkbox" id="__nav_6" >
      
      
      
      
        <label class="md-nav__link" for="__nav_6">
          第六章:融合Mysql的RAG系统
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="第六章:融合Mysql的RAG系统" data-md-level="1">
        <label class="md-nav__title" for="__nav_6">
          <span class="md-nav__icon md-icon"></span>
          第六章:融合Mysql的RAG系统
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E7%AC%AC%E5%85%AD%E7%AB%A0%EF%BC%9A%E8%9E%8D%E5%90%88Mysql%E7%9A%84RAG%E7%B3%BB%E7%BB%9F/01-%E8%9E%8D%E5%90%88FQA%E5%92%8C%E7%9F%A5%E8%AF%86%E5%BA%93%E6%9F%A5%E8%AF%A2.html" class="md-nav__link">
        6.1 融合FQA和知识库查询
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E7%AC%AC%E5%85%AD%E7%AB%A0%EF%BC%9A%E8%9E%8D%E5%90%88Mysql%E7%9A%84RAG%E7%B3%BB%E7%BB%9F/02-%E5%A2%9E%E5%BC%BA%E5%9E%8BFAQ%E4%B8%8E%E7%9F%A5%E8%AF%86%E5%BA%93%E8%9E%8D%E5%90%88%E6%9F%A5%E8%AF%A2.html" class="md-nav__link">
        6.2 增强型FAQ与知识库融合查询
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E7%AC%AC%E5%85%AD%E7%AB%A0%EF%BC%9A%E8%9E%8D%E5%90%88Mysql%E7%9A%84RAG%E7%B3%BB%E7%BB%9F/03-%E7%B3%BB%E7%BB%9FAPI%E6%8E%A5%E5%8F%A3%E5%BC%80%E5%8F%91%E5%8F%8Awebui%E5%BA%94%E7%94%A8.html" class="md-nav__link">
        6.3 系统API接口开发及webui应用
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E7%AC%AC%E5%85%AD%E7%AB%A0%EF%BC%9A%E8%9E%8D%E5%90%88Mysql%E7%9A%84RAG%E7%B3%BB%E7%BB%9F/FastAPI%E5%92%8CFlask%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB%28%E6%89%A9%E5%B1%95%E8%B5%84%E6%96%99%29.html" class="md-nav__link">
        6.4 FastAPI和Flask的区别和联系(扩展资料)
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    学习目标
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#edu_document_loaders" class="md-nav__link">
    文档解析工具 (edu_document_loaders/)
  </a>
  
    <nav class="md-nav" aria-label="文档解析工具 (edu_document_loaders/)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#ocr-edu_ocrpy" class="md-nav__link">
    OCR 引擎核心 (edu_ocr.py)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pdf-edu_pdfloaderpy" class="md-nav__link">
    PDF 文档加载器 (edu_pdfloader.py)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#word-edu_docloaderpy" class="md-nav__link">
    Word 文档加载器 (edu_docloader.py)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#powerpoint-edu_pptloaderpy" class="md-nav__link">
    PowerPoint 文档加载器 (edu_pptloader.py)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#edu_imgloaderpy" class="md-nav__link">
    图像文件加载器 (edu_imgloader.py)
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#edu_text_spliter" class="md-nav__link">
    文本切分工具 (edu_text_spliter/)
  </a>
  
    <nav class="md-nav" aria-label="文本切分工具 (edu_text_spliter/)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#edu_chinese_recursive_text_splitterpy" class="md-nav__link">
    中文递归文本切分器 (edu_chinese_recursive_text_splitter.py)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#edu_model_text_spliterpy" class="md-nav__link">
    基于模型的语义切分器 (edu_model_text_spliter.py)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_3" class="md-nav__link">
    本章总结
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<h1 id="_1">文档解析与文本切分利器<a class="headerlink" href="#_1" title="Permanent link">&para;</a></h1>
<h2 id="_2">学习目标<a class="headerlink" href="#_2" title="Permanent link">&para;</a></h2>
<ul>
<li>掌握系统中用于解析不同文档格式（PDF, DOCX, PPTX, Images）的核心工具。</li>
<li>理解光学字符识别（OCR）工具 <code>RapidOCR</code> 如何集成并应用于文档解析流程。</li>
<li>了解系统中提供的两种文本切分工具：基于规则的递归切分器和基于模型的语义切分器。</li>
<li>熟悉 <code>edu_document_loaders</code> 和 <code>edu_text_spliter</code> 目录下各脚本的具体实现和功能。</li>
</ul>
<h2 id="edu_document_loaders">文档解析工具 (<code>edu_document_loaders/</code>)<a class="headerlink" href="#edu_document_loaders" title="Permanent link">&para;</a></h2>
<p>为了从各种常见的 IT 教育文档格式中提取信息，系统实现了一系列专门的加载器（Loaders）。这些加载器不仅能提取文档中的原生文本，还能利用 OCR 技术识别并提取图片中嵌入的文字。它们都继承自 Langchain 的 <code>BaseLoader</code>，并实现了 <code>lazy_load</code> 方法来按需生成 <code>Document</code> 对象。</p>
<h3 id="ocr-edu_ocrpy">OCR 引擎核心 (edu_ocr.py)<a class="headerlink" href="#ocr-edu_ocrpy" title="Permanent link">&para;</a></h3>
<p>该脚本提供了一个标准化的函数 <code>get_ocr()</code> 来初始化和获取 OCR 识别引擎实例。这是所有需要图片文字识别功能的加载器的基础。</p>
<ul>
<li><strong>功能</strong>: 初始化 <code>RapidOCR</code> 实例。</li>
</ul>
<ul>
<li><strong>特点</strong>：<ul>
<li><strong>引擎选择</strong>: 优先尝试 <code>rapidocr_paddle</code> (利用 PaddlePaddle 推理，推荐 GPU 环境)，若失败则回退到 <code>rapidocr_onnxruntime</code> (利用 ONNX Runtime 推理，适合 CPU 环境或需要跨平台部署的场景)。</li>
<li><strong>参数控制</strong>: 允许通过 <code>use_cuda</code> 参数控制是否启用 GPU 加速（如果使用 PaddlePaddle 引擎）。</li>
</ul>
</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="c1"># edu_document_loaders/edu_ocr.py 源码</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">TYPE_CHECKING</span>
<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">paddleocr：解析图片中的文字，也可以进行表格识别</span>
<span class="sd">rapidocr_paddle 和 rapidocr_onnxruntime 两种导入方式</span>
<span class="sd">主要区别在于它们所使用的推理引擎和硬件支持</span>
<span class="sd">选择哪种方式最合适取决于你的硬件环境和性能需求。</span>
<span class="sd">当你有 GPU 且追求速度时：使用 rapidocr_paddle。PaddlePaddle 原生支持在 GPU 上推理 PaddleOCR 模型，速度更快。</span>
<span class="sd">当只有 CPU 且需要高效推理时：使用 rapidocr_onnxruntime。它在 CPU 上进行了优化，资源占用较低.</span>
<span class="sd">&#39;&#39;&#39;</span>

<span class="k">def</span> <span class="nf">get_ocr</span><span class="p">(</span><span class="n">use_cuda</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;RapidOCR&quot;</span><span class="p">:</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">rapidocr_paddle</span> <span class="kn">import</span> <span class="n">RapidOCR</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        det_use_cuda=True：启用检测模型的GPU加速。cls_use_cuda=True：启用分类模型的GPU加速。rec_use_cuda=True：启用识别模型的GPU加速。</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">ocr</span> <span class="o">=</span> <span class="n">RapidOCR</span><span class="p">(</span><span class="n">det_use_cuda</span><span class="o">=</span><span class="n">use_cuda</span><span class="p">,</span> <span class="n">cls_use_cuda</span><span class="o">=</span><span class="n">use_cuda</span><span class="p">,</span> <span class="n">rec_use_cuda</span><span class="o">=</span><span class="n">use_cuda</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
        <span class="c1">#</span>
        <span class="kn">from</span> <span class="nn">rapidocr_onnxruntime</span> <span class="kn">import</span> <span class="n">RapidOCR</span>
        <span class="n">ocr</span> <span class="o">=</span> <span class="n">RapidOCR</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">ocr</span>
</code></pre></div>
<h3 id="pdf-edu_pdfloaderpy">PDF 文档加载器 (edu_pdfloader.py)<a class="headerlink" href="#pdf-edu_pdfloaderpy" title="Permanent link">&para;</a></h3>
<p><code>OCRPDFLoader</code> 类专门用于处理 PDF 文件。</p>
<ul>
<li><strong>功能</strong>: 解析 PDF，提取文本和图片中的文字。</li>
</ul>
<ul>
<li><strong>依赖</strong>: <code>PyMuPDF</code> (fitz), <code>Pillow</code>, <code>numpy</code>, <code>opencv-python</code>, <code>tqdm</code> 以及 <code>edu_ocr.py</code>。</li>
</ul>
<ul>
<li><strong>核心逻辑</strong>: <ol>
<li>使用 <code>fitz.open()</code> 打开 PDF。</li>
<li>逐页 (<code>page</code>) 处理。</li>
<li>使用 <code>page.get_text()</code> 提取原生文本。</li>
<li>使用 <code>page.get_image_info(xrefs=True)</code> 获取页面上的图片信息。</li>
<li><strong>OCR 应用</strong>: 对获取到的图片，检查其尺寸是否超过预设阈值 <code>PDF_OCR_THRESHOLD</code>（默认为页面宽高的 60%）。仅对大于阈值的图片执行 OCR。</li>
<li>处理页面旋转 (<code>page.rotation</code>)，确保 OCR 时图像方向正确。</li>
<li>调用 <code>get_ocr()</code> 获取的 OCR 实例识别图片文字。</li>
<li>合并原生文本和 OCR 结果。</li>
<li>使用 <code>tqdm</code> 显示处理进度。</li>
</ol>
</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="c1"># edu_document_loaders/edu_pdfloader.py 源码</span>
<span class="kn">import</span> <span class="nn">cv2</span>
<span class="kn">import</span> <span class="nn">fitz</span>  <span class="c1"># pyMuPDF里面的fitz包，不要与pip install fitz混淆</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">PIL</span> <span class="kn">import</span> <span class="n">Image</span>
<span class="kn">from</span> <span class="nn">tqdm</span> <span class="kn">import</span> <span class="n">tqdm</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Iterator</span>
<span class="kn">from</span> <span class="nn">edu_ocr</span> <span class="kn">import</span> <span class="n">get_ocr</span>
<span class="kn">from</span> <span class="nn">langchain_core.documents</span> <span class="kn">import</span> <span class="n">Document</span>
<span class="kn">from</span> <span class="nn">langchain_core.document_loaders</span> <span class="kn">import</span> <span class="n">BaseLoader</span>
<span class="kn">from</span> <span class="nn">langchain.text_splitter</span> <span class="kn">import</span> <span class="n">CharacterTextSplitter</span>
<span class="c1"># PDF OCR 控制：只对宽高超过页面一定比例（图片宽/页面宽，图片高/页面高）的图片进行 OCR。</span>
<span class="c1"># 这样可以避免 PDF 中一些小图片的干扰，提高非扫描版 PDF 处理速度</span>
<span class="n">PDF_OCR_THRESHOLD</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">OCRPDFLoader</span><span class="p">(</span><span class="n">BaseLoader</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;An example document loader that reads a file line by line.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Initialize the loader with a file path.</span>

<span class="sd">        Args:</span>
<span class="sd">            file_path: The path to the file to load.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">file_path</span> <span class="o">=</span> <span class="n">file_path</span>

    <span class="k">def</span> <span class="nf">lazy_load</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="n">Document</span><span class="p">]:</span>
        <span class="c1"># &lt;-- Does not take any arguments</span>
        <span class="sd">&quot;&quot;&quot;A lazy loader that reads a file line by line.</span>

<span class="sd">        When you&#39;re implementing lazy load methods, you should use a generator</span>
<span class="sd">        to yield documents one by one.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">line</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pdf2text</span><span class="p">()</span>
        <span class="k">yield</span> <span class="n">Document</span><span class="p">(</span><span class="n">page_content</span><span class="o">=</span><span class="n">line</span><span class="p">,</span> <span class="n">metadata</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;source&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">file_path</span><span class="p">})</span>



    <span class="k">def</span> <span class="nf">pdf2text</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">ocr</span> <span class="o">=</span> <span class="n">get_ocr</span><span class="p">()</span>
        <span class="c1"># 打开pdf文件</span>
        <span class="n">doc</span> <span class="o">=</span> <span class="n">fitz</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file_path</span><span class="p">)</span>
        <span class="c1">## 获取页数</span>
        <span class="c1"># print(f&#39;len(doc)--&gt;{len(doc)}&#39;)</span>
        <span class="n">resp</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="n">b_unit</span> <span class="o">=</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">total</span><span class="o">=</span><span class="n">doc</span><span class="o">.</span><span class="n">page_count</span><span class="p">,</span> <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;OCRPDFLoader context page index: 0&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">page</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">doc</span><span class="p">):</span>
            <span class="n">b_unit</span><span class="o">.</span><span class="n">set_description</span><span class="p">(</span><span class="s2">&quot;OCRPDFLoader context page index: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
            <span class="n">b_unit</span><span class="o">.</span><span class="n">refresh</span><span class="p">()</span>
            <span class="c1"># 提取文本：默认使用 &quot;text&quot; 模式提取文本。</span>
            <span class="n">text</span> <span class="o">=</span> <span class="n">page</span><span class="o">.</span><span class="n">get_text</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
            <span class="n">resp</span> <span class="o">+=</span> <span class="n">text</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="c1"># print(f&#39;resp--&gt;{resp}&#39;)</span>
            <span class="c1"># 获取图片：获得所有显示的图像的元信息列表。</span>
            <span class="c1"># 它适用于所有文档类型，不仅限于 PDF。</span>
            <span class="n">img_list</span> <span class="o">=</span> <span class="n">page</span><span class="o">.</span><span class="n">get_image_info</span><span class="p">(</span><span class="n">xrefs</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="c1"># print(f&#39;img_list--》{img_list}&#39;)</span>
            <span class="c1"># print(f&#39;img_list--》{len(img_list)}&#39;)</span>
            <span class="k">for</span> <span class="n">img</span> <span class="ow">in</span> <span class="n">img_list</span><span class="p">:</span>
                <span class="c1"># xref一种编号，指向该图像对象在PDF文件中的位置，程序可以通过这个编号快速定位和提取图像数据。</span>
                <span class="k">if</span> <span class="n">xref</span> <span class="o">:=</span> <span class="n">img</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;xref&quot;</span><span class="p">):</span>
                    <span class="c1"># 图像在页面上的位置和尺寸。</span>
                    <span class="n">bbox</span> <span class="o">=</span> <span class="n">img</span><span class="p">[</span><span class="s2">&quot;bbox&quot;</span><span class="p">]</span>
                    <span class="c1"># 检查图片尺寸是否超过设定的阈值</span>
                    <span class="c1"># if ((bbox[2] - bbox[0]) / (page.rect.width) &lt; PDF_OCR_THRESHOLD[0]</span>
                    <span class="c1">#         or (bbox[3] - bbox[1]) / (page.rect.height) &lt; PDF_OCR_THRESHOLD[1]):</span>
                    <span class="c1">#     continue</span>
                    <span class="n">pix</span> <span class="o">=</span> <span class="n">fitz</span><span class="o">.</span><span class="n">Pixmap</span><span class="p">(</span><span class="n">doc</span><span class="p">,</span> <span class="n">xref</span><span class="p">)</span>
                    <span class="c1"># print(f&#39;page.rotation--&gt;{page.rotation}&#39;)</span>
                    <span class="k">if</span> <span class="nb">int</span><span class="p">(</span><span class="n">page</span><span class="o">.</span><span class="n">rotation</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># 如果Page有旋转角度，则旋转图片</span>
                        <span class="n">img_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">frombuffer</span><span class="p">(</span><span class="n">pix</span><span class="o">.</span><span class="n">samples</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">pix</span><span class="o">.</span><span class="n">height</span><span class="p">,</span> <span class="n">pix</span><span class="o">.</span><span class="n">width</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                        <span class="n">tmp_img</span> <span class="o">=</span> <span class="n">Image</span><span class="o">.</span><span class="n">fromarray</span><span class="p">(</span><span class="n">img_array</span><span class="p">)</span>
                        <span class="n">ori_img</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">cvtColor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">tmp_img</span><span class="p">),</span> <span class="n">cv2</span><span class="o">.</span><span class="n">COLOR_RGB2BGR</span><span class="p">)</span>
                        <span class="n">rot_img</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rotate_img</span><span class="p">(</span><span class="n">img</span><span class="o">=</span><span class="n">ori_img</span><span class="p">,</span> <span class="n">angle</span><span class="o">=</span><span class="mi">360</span> <span class="o">-</span> <span class="n">page</span><span class="o">.</span><span class="n">rotation</span><span class="p">)</span>
                        <span class="n">img_array</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">cvtColor</span><span class="p">(</span><span class="n">rot_img</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">COLOR_RGB2BGR</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">img_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">frombuffer</span><span class="p">(</span><span class="n">pix</span><span class="o">.</span><span class="n">samples</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">pix</span><span class="o">.</span><span class="n">height</span><span class="p">,</span> <span class="n">pix</span><span class="o">.</span><span class="n">width</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

                    <span class="c1"># result：包含了图像中检测到的所有文本框的位置、文本内容和置信度信息。</span>
                    <span class="c1"># _：它是一个包含了时间数据的列表，可以用于优化模型运行速度。</span>
                    <span class="n">result</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">ocr</span><span class="p">(</span><span class="n">img_array</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">result</span><span class="p">:</span>
                        <span class="n">ocr_result</span> <span class="o">=</span> <span class="p">[</span><span class="n">line</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">result</span><span class="p">]</span>
                        <span class="n">resp</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">ocr_result</span><span class="p">)</span>
            <span class="c1"># 更新进度</span>
            <span class="n">b_unit</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">resp</span>



<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">pdf_loader</span> <span class="o">=</span> <span class="n">OCRPDFLoader</span><span class="p">(</span><span class="n">file_path</span><span class="o">=</span><span class="s2">&quot;./data/Python机器学习基础教程.pdf&quot;</span><span class="p">)</span>
    <span class="n">doc</span> <span class="o">=</span> <span class="n">pdf_loader</span><span class="o">.</span><span class="n">load</span><span class="p">()</span>

    <span class="nb">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">doc</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span>
    <span class="c1"># text_spliter = CharacterTextSplitter(chunk_size=300, chunk_overlap=20)</span>
    <span class="c1"># result = text_spliter.split_documents(doc)</span>
    <span class="c1"># print(len(result))</span>
    <span class="c1"># print(result[0])</span>
</code></pre></div>
<p><em>(注意：上述代码中 self.rotate_img 方法未在提供的代码段中定义，实际使用时需要确保该方法存在或移除相关调用)</em></p>
<h3 id="word-edu_docloaderpy">Word 文档加载器 (edu_docloader.py)<a class="headerlink" href="#word-edu_docloaderpy" title="Permanent link">&para;</a></h3>
<p><code>OCRDOCLoader</code> 类用于处理 <code>.docx</code> 文件。</p>
<ul>
<li><strong>功能</strong>: 解析 DOCX 文件，提取段落、表格文本，并对嵌入的图片进行 OCR。</li>
</ul>
<ul>
<li><strong>依赖</strong>: <code>python-docx</code>, <code>Pillow</code>, <code>numpy</code>, <code>tqdm</code> 以及 <code>edu_ocr.py</code>。</li>
</ul>
<ul>
<li><strong>核心逻辑</strong>: <ol>
<li>使用 <code>docx.Document()</code> 打开 DOCX 文件。</li>
<li>定义 <code>iter_block_items</code> 辅助函数，用于统一遍历文档中的段落 (<code>Paragraph</code>) 和表格 (<code>Table</code>) 块。</li>
<li>遍历所有块： <ul>
<li>如果是段落，提取 <code>block.text</code>。同时，使用 XPath (<code>.//pic:pic</code>, <code>.//a:blip/@r:embed</code>) 查找并提取段落内嵌入的图片。对提取的图片执行 OCR。</li>
<li>如果是表格，遍历所有单元格 (<code>cell</code>)，提取单元格内段落的文本。</li>
</ul>
</li>
<li>合并所有提取的文本和 OCR 结果。</li>
<li>使用 <code>tqdm</code> 显示处理进度。</li>
</ol>
</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="c1"># edu_document_loaders/edu_docloader.py 源码</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Iterator</span>
<span class="kn">from</span> <span class="nn">.edu_ocr</span> <span class="kn">import</span> <span class="n">get_ocr</span>
<span class="c1"># 导入必要的模块</span>
<span class="kn">from</span> <span class="nn">tqdm</span> <span class="kn">import</span> <span class="n">tqdm</span>
<span class="kn">from</span> <span class="nn">docx.table</span> <span class="kn">import</span> <span class="n">_Cell</span><span class="p">,</span> <span class="n">Table</span>  <span class="c1"># 用于处理表格</span>
<span class="kn">from</span> <span class="nn">docx.oxml.table</span> <span class="kn">import</span> <span class="n">CT_Tbl</span>  <span class="c1"># 用于处理表格XML结构</span>
<span class="kn">from</span> <span class="nn">docx.oxml.text.paragraph</span> <span class="kn">import</span> <span class="n">CT_P</span>  <span class="c1"># 用于处理段落XML结构</span>
<span class="kn">from</span> <span class="nn">docx.text.paragraph</span> <span class="kn">import</span> <span class="n">Paragraph</span>  <span class="c1"># 用于处理段落内容</span>
<span class="kn">from</span> <span class="nn">docx</span> <span class="kn">import</span> <span class="n">Document</span> <span class="k">as</span> <span class="n">Docu1</span>
<span class="kn">from</span> <span class="nn">docx.document</span> <span class="kn">import</span> <span class="n">Document</span> <span class="k">as</span> <span class="n">Docu2</span>
<span class="kn">from</span> <span class="nn">docx</span> <span class="kn">import</span> <span class="n">ImagePart</span>  <span class="c1"># 用于处理Word文档和图片</span>
<span class="kn">from</span> <span class="nn">PIL</span> <span class="kn">import</span> <span class="n">Image</span>  <span class="c1"># 用于处理图片</span>
<span class="kn">from</span> <span class="nn">io</span> <span class="kn">import</span> <span class="n">BytesIO</span>  <span class="c1"># 用于将字节流转换为图片</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>  <span class="c1"># 用于处理数组</span>
<span class="kn">from</span> <span class="nn">langchain_core.documents</span> <span class="kn">import</span> <span class="n">Document</span>
<span class="kn">from</span> <span class="nn">langchain_core.document_loaders</span> <span class="kn">import</span> <span class="n">BaseLoader</span>


<span class="k">class</span> <span class="nc">OCRDOCLoader</span><span class="p">(</span><span class="n">BaseLoader</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;An example document loader that reads a file line by line.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filepath</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Initialize the loader with a file path.</span>

<span class="sd">        Args:</span>
<span class="sd">            filepath_path: The path to the filepath to load.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filepath</span> <span class="o">=</span> <span class="n">filepath</span>

    <span class="k">def</span> <span class="nf">lazy_load</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="n">Document</span><span class="p">]:</span>
        <span class="c1"># &lt;-- Does not take any arguments</span>
        <span class="sd">&quot;&quot;&quot;A lazy loader that reads a file line by line.</span>

<span class="sd">        When you&#39;re implementing lazy load methods, you should use a generator</span>
<span class="sd">        to yield documents one by one.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">line</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">doc2text</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filepath</span><span class="p">)</span>
        <span class="k">yield</span> <span class="n">Document</span><span class="p">(</span><span class="n">page_content</span><span class="o">=</span><span class="n">line</span><span class="p">,</span> <span class="n">metadata</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;source&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">filepath</span><span class="p">})</span>

    <span class="k">def</span> <span class="nf">doc2text</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filepath</span><span class="p">):</span>

        <span class="c1"># 创建OCR识别对象</span>
        <span class="n">ocr</span> <span class="o">=</span> <span class="n">get_ocr</span><span class="p">()</span>
        <span class="c1"># print(f&#39;ocr--》{ocr}&#39;)  # 输出OCR对象信息</span>

        <span class="c1"># 读取Word文档</span>
        <span class="n">doc</span> <span class="o">=</span> <span class="n">Docu1</span><span class="p">(</span><span class="n">filepath</span><span class="p">)</span>
        <span class="c1"># print(f&#39;doc--&gt;{doc}&#39;)  # 输出读取到的文档信息</span>
        <span class="c1"># 定义一个空字符串用于存储最终的文本内容</span>
        <span class="n">resp</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="c1"># 定义一个迭代器，用于遍历文档中的块（段落、表格等）</span>
        <span class="k">def</span> <span class="nf">iter_block_items</span><span class="p">(</span><span class="n">parent</span><span class="p">):</span>
            <span class="c1"># 判断parent对象类型，如果是Document类型，则获取其元素</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">Docu2</span><span class="p">):</span>
                <span class="n">parent_elm</span> <span class="o">=</span> <span class="n">parent</span><span class="o">.</span><span class="n">element</span><span class="o">.</span><span class="n">body</span>
            <span class="c1"># 如果是表格单元格类型，获取单元格的XML元素</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">_Cell</span><span class="p">):</span>
                <span class="n">parent_elm</span> <span class="o">=</span> <span class="n">parent</span><span class="o">.</span><span class="n">_tc</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;OCRDOCLoader parse fail&quot;</span><span class="p">)</span>  <span class="c1"># 如果都不是，则抛出错误</span>
            <span class="c1"># print(f&#39;parent_elm--》{parent_elm}&#39;)</span>
            <span class="c1"># print(&#39;*&#39;*80)</span>
            <span class="c1"># 遍历parent_elm中的所有子元素</span>
            <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">parent_elm</span><span class="o">.</span><span class="n">iterchildren</span><span class="p">():</span>
                <span class="c1"># print(f&#39;child--》{child}&#39;)</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">CT_P</span><span class="p">):</span>  <span class="c1"># 如果是段落类型</span>
                    <span class="k">yield</span> <span class="n">Paragraph</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">parent</span><span class="p">)</span>  <span class="c1"># 返回段落</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">CT_Tbl</span><span class="p">):</span>  <span class="c1"># 如果是表格类型</span>
                    <span class="k">yield</span> <span class="n">Table</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">parent</span><span class="p">)</span>  <span class="c1"># 返回表格</span>

        <span class="c1"># print(f&#39;doc.paragraphs--&gt;{doc.paragraphs}&#39;)</span>
        <span class="c1"># print(f&#39;doc.tables--&gt;{doc.tables}&#39;)</span>
        <span class="c1"># 创建进度条，表示文档处理的进度</span>
        <span class="n">b_unit</span> <span class="o">=</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">total</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">doc</span><span class="o">.</span><span class="n">paragraphs</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">doc</span><span class="o">.</span><span class="n">tables</span><span class="p">),</span>
                      <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;OCRDOCLoader block index: 0&quot;</span><span class="p">)</span>

        <span class="c1"># 遍历文档中的所有块（段落和表格）</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">block</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">iter_block_items</span><span class="p">(</span><span class="n">doc</span><span class="p">)):</span>
            <span class="c1"># 更新进度条描述</span>
            <span class="n">b_unit</span><span class="o">.</span><span class="n">set_description</span><span class="p">(</span><span class="s2">&quot;OCRDOCLoader  block index: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
            <span class="n">b_unit</span><span class="o">.</span><span class="n">refresh</span><span class="p">()</span>  <span class="c1"># 刷新进度条</span>

            <span class="c1"># 如果块是段落类型</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="n">Paragraph</span><span class="p">):</span>
                <span class="n">resp</span> <span class="o">+=</span> <span class="n">block</span><span class="o">.</span><span class="n">text</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>  <span class="c1"># 将段落文本加入到返回字符串中</span>
                <span class="c1"># 获取段落中的所有图片</span>
                <span class="n">images</span> <span class="o">=</span> <span class="n">block</span><span class="o">.</span><span class="n">_element</span><span class="o">.</span><span class="n">xpath</span><span class="p">(</span><span class="s1">&#39;.//pic:pic&#39;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">image</span> <span class="ow">in</span> <span class="n">images</span><span class="p">:</span>
                    <span class="c1"># 遍历图片，获取图片ID</span>
                    <span class="k">for</span> <span class="n">img_id</span> <span class="ow">in</span> <span class="n">image</span><span class="o">.</span><span class="n">xpath</span><span class="p">(</span><span class="s1">&#39;.//a:blip/@r:embed&#39;</span><span class="p">):</span>
                        <span class="n">part</span> <span class="o">=</span> <span class="n">doc</span><span class="o">.</span><span class="n">part</span><span class="o">.</span><span class="n">related_parts</span><span class="p">[</span><span class="n">img_id</span><span class="p">]</span>  <span class="c1"># 根据图片ID获取图片对象</span>
                        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">part</span><span class="p">,</span> <span class="n">ImagePart</span><span class="p">):</span>  <span class="c1"># 如果该部分是图片</span>
                            <span class="c1"># BytesIO 是 Python 内置的 io 模块中的一个类，用于在内存中读写二进制数据</span>
                            <span class="c1"># part._blob 通常表示从某个文档（如 DOCX 文件）中提取的二进制内容。</span>
                            <span class="n">image</span> <span class="o">=</span> <span class="n">Image</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">BytesIO</span><span class="p">(</span><span class="n">part</span><span class="o">.</span><span class="n">_blob</span><span class="p">))</span>  <span class="c1"># 打开图片</span>
                            <span class="n">result</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">ocr</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">image</span><span class="p">))</span>  <span class="c1"># 使用OCR识别图片中的文字</span>
                            <span class="k">if</span> <span class="n">result</span><span class="p">:</span>  <span class="c1"># 如果识别结果不为空</span>
                                <span class="n">ocr_result</span> <span class="o">=</span> <span class="p">[</span><span class="n">line</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">result</span><span class="p">]</span>  <span class="c1"># 提取识别出的文字</span>
                                <span class="n">resp</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">ocr_result</span><span class="p">)</span>  <span class="c1"># 将识别结果加入返回文本中</span>
            <span class="c1"># 如果块是表格类型</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="n">Table</span><span class="p">):</span>
                <span class="c1"># 遍历表格中的所有行和单元格</span>
                <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">block</span><span class="o">.</span><span class="n">rows</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="n">row</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">paragraph</span> <span class="ow">in</span> <span class="n">cell</span><span class="o">.</span><span class="n">paragraphs</span><span class="p">:</span>
                            <span class="n">resp</span> <span class="o">+=</span> <span class="n">paragraph</span><span class="o">.</span><span class="n">text</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>  <span class="c1"># 将单元格内的段落文本加入返回文本中</span>

            <span class="c1"># 更新进度条</span>
            <span class="n">b_unit</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1"># 返回提取的文本内容</span>
        <span class="k">return</span> <span class="n">resp</span>



<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">docx_loader</span> <span class="o">=</span> <span class="n">OCRDOCLoader</span><span class="p">(</span><span class="n">filepath</span><span class="o">=</span><span class="s1">&#39;./data/b.docx&#39;</span><span class="p">)</span>
    <span class="n">doc</span> <span class="o">=</span> <span class="n">docx_loader</span><span class="o">.</span><span class="n">load</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span>
</code></pre></div>
<h3 id="powerpoint-edu_pptloaderpy">PowerPoint 文档加载器 (edu_pptloader.py)<a class="headerlink" href="#powerpoint-edu_pptloaderpy" title="Permanent link">&para;</a></h3>
<p><code>OCRPPTLoader</code> 类用于处理 <code>.ppt</code> 和 <code>.pptx</code> 文件。</p>
<ul>
<li><strong>功能</strong>: 解析 PPT/PPTX 文件，提取形状（文本框、表格）、图片中的文本。</li>
</ul>
<ul>
<li><strong>依赖</strong>: <code>python-pptx</code>, <code>Pillow</code>, <code>numpy</code>, <code>tqdm</code> 以及 <code>edu_ocr.py</code>。</li>
</ul>
<ul>
<li>
<p><strong>核心逻辑</strong>: </p>
<ol>
<li>
<p>使用 <code>pptx.Presentation()</code> 打开演示文稿。</p>
</li>
<li>
<p>逐张幻灯片 (<code>slide</code>) 处理。</p>
</li>
<li>
<p><strong>顺序处理</strong>: 将幻灯片上的形状 (<code>shape</code>) 按视觉顺序（<code>top</code>, <code>left</code> 坐标）排序。</p>
</li>
<li>
<p>定义 extract_text 递归函数处理单个形状： </p>
<ul>
<li>提取文本框 (<code>shape.has_text_frame</code>) 的文本。</li>
<li>提取表格 (<code>shape.has_table</code>) 内所有单元格的文本。</li>
<li>如果形状是图片 (<code>shape.shape_type == 13</code>)，提取图片数据 (<code>shape.image.blob</code>)，执行 OCR。</li>
<li>如果形状是组合 (<code>shape.shape_type == 6</code>)，递归调用 <code>extract_text</code> 处理其包含的子形状。</li>
</ul>
</li>
<li>
<p>遍历排序后的形状，调用 <code>extract_text</code>。</p>
</li>
<li>
<p>合并所有提取的文本和 OCR 结果。</p>
</li>
<li>
<p>使用 <code>tqdm</code> 显示处理进度。</p>
</li>
</ol>
</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="c1"># edu_document_loaders/edu_pptloader.py 源码</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Iterator</span>
<span class="kn">from</span> <span class="nn">edu_ocr</span> <span class="kn">import</span> <span class="n">get_ocr</span>
<span class="kn">from</span> <span class="nn">langchain_core.documents</span> <span class="kn">import</span> <span class="n">Document</span>
<span class="kn">from</span> <span class="nn">langchain_core.document_loaders</span> <span class="kn">import</span> <span class="n">BaseLoader</span>
<span class="kn">from</span> <span class="nn">pptx</span> <span class="kn">import</span> <span class="n">Presentation</span>
<span class="kn">from</span> <span class="nn">PIL</span> <span class="kn">import</span> <span class="n">Image</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">io</span> <span class="kn">import</span> <span class="n">BytesIO</span>
<span class="kn">from</span> <span class="nn">tqdm</span> <span class="kn">import</span> <span class="n">tqdm</span>


<span class="k">class</span> <span class="nc">OCRPPTLoader</span><span class="p">(</span><span class="n">BaseLoader</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;An example document loader that reads a file line by line.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filepath</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Initialize the loader with a file path.</span>

<span class="sd">        Args:</span>
<span class="sd">            filepath: The path to the ppt to load.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filepath</span> <span class="o">=</span> <span class="n">filepath</span>

    <span class="k">def</span> <span class="nf">lazy_load</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="n">Document</span><span class="p">]:</span>
        <span class="c1"># &lt;-- Does not take any arguments</span>
        <span class="sd">&quot;&quot;&quot;A lazy loader that reads a file line by line.</span>

<span class="sd">        When you&#39;re implementing lazy load methods, you should use a generator</span>
<span class="sd">        to yield documents one by one.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">line</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ppt2text</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filepath</span><span class="p">)</span>
        <span class="k">yield</span> <span class="n">Document</span><span class="p">(</span><span class="n">page_content</span><span class="o">=</span><span class="n">line</span><span class="p">,</span> <span class="n">metadata</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;source&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">filepath</span><span class="p">})</span>

    <span class="k">def</span> <span class="nf">ppt2text</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filepath</span><span class="p">):</span>
        <span class="c1"># 打开指定路径的 PowerPoint 文件</span>
        <span class="n">prs</span> <span class="o">=</span> <span class="n">Presentation</span><span class="p">(</span><span class="n">filepath</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;prs--&gt;</span><span class="si">{</span><span class="n">prs</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="c1"># 获取 OCR 功能的实例</span>
        <span class="n">ocr</span> <span class="o">=</span> <span class="n">get_ocr</span><span class="p">()</span>
        <span class="c1"># 初始化一个空字符串，用于存储提取的文本内容</span>
        <span class="n">resp</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">extract_text</span><span class="p">(</span><span class="n">shape</span><span class="p">):</span>
            <span class="c1"># nonlocal指明resp非全局非局部，而是外部嵌套函数中的变量，</span>
            <span class="c1"># 允许内部函数访问和修改外部函数中定义的变量resp</span>
            <span class="k">nonlocal</span> <span class="n">resp</span>

            <span class="c1"># 检查形状是否有文本框</span>
            <span class="k">if</span> <span class="n">shape</span><span class="o">.</span><span class="n">has_text_frame</span><span class="p">:</span>
                <span class="c1"># 将文本框中的文本添加到resp中，并去掉前后空格</span>
                <span class="n">resp</span> <span class="o">+=</span> <span class="n">shape</span><span class="o">.</span><span class="n">text</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>

            <span class="c1"># 检查形状是否为表格</span>
            <span class="k">if</span> <span class="n">shape</span><span class="o">.</span><span class="n">has_table</span><span class="p">:</span>
                <span class="c1"># 遍历表格的每一行</span>
                <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">shape</span><span class="o">.</span><span class="n">table</span><span class="o">.</span><span class="n">rows</span><span class="p">:</span>
                    <span class="c1"># 遍历每一行中的每个单元格</span>
                    <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="n">row</span><span class="o">.</span><span class="n">cells</span><span class="p">:</span>
                        <span class="c1"># 遍历单元格中的每个段落</span>
                        <span class="k">for</span> <span class="n">paragraph</span> <span class="ow">in</span> <span class="n">cell</span><span class="o">.</span><span class="n">text_frame</span><span class="o">.</span><span class="n">paragraphs</span><span class="p">:</span>
                            <span class="c1"># 将单元格中的文本添加到resp中，并去掉前后空格</span>
                            <span class="n">resp</span> <span class="o">+=</span> <span class="n">paragraph</span><span class="o">.</span><span class="n">text</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>

            <span class="c1"># 检查形状是否为图片（shape_type == 13）</span>
            <span class="k">if</span> <span class="n">shape</span><span class="o">.</span><span class="n">shape_type</span> <span class="o">==</span> <span class="mi">13</span><span class="p">:</span>  <span class="c1"># 13 表示图片</span>
                <span class="c1"># 使用 BytesIO 打开图片数据并转换为图像对象</span>
                <span class="n">image</span> <span class="o">=</span> <span class="n">Image</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">BytesIO</span><span class="p">(</span><span class="n">shape</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">blob</span><span class="p">))</span>
                <span class="c1"># 使用 OCR 处理图像并获取结果</span>
                <span class="n">result</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">ocr</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">image</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">result</span><span class="p">:</span>  <span class="c1"># 如果 OCR 有结果</span>
                    <span class="c1"># 提取 OCR 结果中的文本行</span>
                    <span class="n">ocr_result</span> <span class="o">=</span> <span class="p">[</span><span class="n">line</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">result</span><span class="p">]</span>
                    <span class="c1"># 将 OCR 提取的文本添加到resp中，以换行分隔</span>
                    <span class="n">resp</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">ocr_result</span><span class="p">)</span>

            <span class="c1"># 检查形状是否为组合形状（shape_type == 6）</span>
            <span class="k">elif</span> <span class="n">shape</span><span class="o">.</span><span class="n">shape_type</span> <span class="o">==</span> <span class="mi">6</span><span class="p">:</span>  <span class="c1"># 6 表示组合</span>
                <span class="c1"># 遍历组合形状中的每个子形状，递归调用extract_text函数</span>
                <span class="k">for</span> <span class="n">child_shape</span> <span class="ow">in</span> <span class="n">shape</span><span class="o">.</span><span class="n">shapes</span><span class="p">:</span>
                    <span class="n">extract_text</span><span class="p">(</span><span class="n">child_shape</span><span class="p">)</span>

        <span class="c1"># 创建一个进度条，用于显示幻灯片处理进度，初始总数为幻灯片数量</span>
        <span class="n">b_unit</span> <span class="o">=</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">total</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">prs</span><span class="o">.</span><span class="n">slides</span><span class="p">),</span> <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;OCRPPTLoader slide index: 1&quot;</span><span class="p">)</span>

        <span class="c1"># 遍历所有幻灯片</span>
        <span class="k">for</span> <span class="n">slide_number</span><span class="p">,</span> <span class="n">slide</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">prs</span><span class="o">.</span><span class="n">slides</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
            <span class="c1"># 更新进度条描述，显示当前处理的幻灯片索引</span>
            <span class="n">b_unit</span><span class="o">.</span><span class="n">set_description</span><span class="p">(</span><span class="s2">&quot;OCRPPTLoader slide index: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">slide_number</span><span class="p">))</span>
            <span class="n">b_unit</span><span class="o">.</span><span class="n">refresh</span><span class="p">()</span>  <span class="c1"># 刷新进度条显示</span>

            <span class="c1"># 按照从上到下、从左到右的顺序对形状进行排序遍历</span>
            <span class="n">sorted_shapes</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">slide</span><span class="o">.</span><span class="n">shapes</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">top</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">left</span><span class="p">))</span>

            <span class="k">for</span> <span class="n">shape</span> <span class="ow">in</span> <span class="n">sorted_shapes</span><span class="p">:</span>
                <span class="n">extract_text</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>  <span class="c1"># 调用extract_text函数提取当前形状的文本内容</span>

            <span class="n">b_unit</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># 更新进度条，表示处理了一张幻灯片</span>

        <span class="k">return</span> <span class="n">resp</span>  <span class="c1"># 返回提取到的所有文本内容</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">img_loader</span> <span class="o">=</span> <span class="n">OCRPPTLoader</span><span class="p">(</span><span class="n">filepath</span><span class="o">=</span><span class="s1">&#39;./data/01.pptx&#39;</span><span class="p">)</span>
    <span class="n">doc</span> <span class="o">=</span> <span class="n">img_loader</span><span class="o">.</span><span class="n">load</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span>
</code></pre></div>
<h3 id="edu_imgloaderpy">图像文件加载器 (edu_imgloader.py)<a class="headerlink" href="#edu_imgloaderpy" title="Permanent link">&para;</a></h3>
<p><code>OCRIMGLoader</code> 类用于直接处理图像文件（如 <code>.png</code>, <code>.jpg</code>）。</p>
<ul>
<li><strong>功能</strong>: 对单个图像文件执行 OCR。</li>
</ul>
<ul>
<li><strong>依赖</strong>: <code>Pillow</code>, <code>numpy</code> 以及 <code>edu_ocr.py</code>。</li>
</ul>
<ul>
<li><strong>核心逻辑</strong>: <ol>
<li>接收图像文件路径 <code>img_path</code>。</li>
<li>调用 <code>get_ocr()</code> 获取 OCR 实例。</li>
<li>直接对图像文件执行 OCR。</li>
<li>将 OCR 结果（所有识别出的文本行）合并成一个字符串。</li>
</ol>
</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="c1"># edu_document_loaders/edu_imgloader.py 源码</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Iterator</span>
<span class="kn">from</span> <span class="nn">edu_ocr</span> <span class="kn">import</span> <span class="n">get_ocr</span>
<span class="kn">from</span> <span class="nn">langchain_core.documents</span> <span class="kn">import</span> <span class="n">Document</span>
<span class="kn">from</span> <span class="nn">langchain_core.document_loaders</span> <span class="kn">import</span> <span class="n">BaseLoader</span>


<span class="k">class</span> <span class="nc">OCRIMGLoader</span><span class="p">(</span><span class="n">BaseLoader</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;An example document loader that reads a file line by line.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">img_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Initialize the loader with a file path.</span>

<span class="sd">        Args:</span>
<span class="sd">            img_path: The path to the img to load.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">img_path</span> <span class="o">=</span> <span class="n">img_path</span>

    <span class="k">def</span> <span class="nf">lazy_load</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="n">Document</span><span class="p">]:</span>
        <span class="c1"># &lt;-- Does not take any arguments</span>
        <span class="sd">&quot;&quot;&quot;A lazy loader that reads a file line by line.</span>

<span class="sd">        When you&#39;re implementing lazy load methods, you should use a generator</span>
<span class="sd">        to yield documents one by one.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">line</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">img2text</span><span class="p">()</span>
        <span class="k">yield</span> <span class="n">Document</span><span class="p">(</span><span class="n">page_content</span><span class="o">=</span><span class="n">line</span><span class="p">,</span> <span class="n">metadata</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;source&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">img_path</span><span class="p">})</span>

    <span class="k">def</span> <span class="nf">img2text</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">resp</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="n">ocr</span> <span class="o">=</span> <span class="n">get_ocr</span><span class="p">()</span>
        <span class="n">result</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">ocr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">img_path</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">result</span><span class="p">:</span>
            <span class="n">ocr_result</span> <span class="o">=</span> <span class="p">[</span><span class="n">line</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">result</span><span class="p">]</span>
            <span class="n">resp</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">ocr_result</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">resp</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">img_loader</span> <span class="o">=</span> <span class="n">OCRIMGLoader</span><span class="p">(</span><span class="n">img_path</span><span class="o">=</span><span class="s1">&#39;./data/test_img.png&#39;</span><span class="p">)</span>
    <span class="n">doc</span> <span class="o">=</span> <span class="n">img_loader</span><span class="o">.</span><span class="n">load</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span>
</code></pre></div>
<h2 id="edu_text_spliter">文本切分工具 (<code>edu_text_spliter/</code>)<a class="headerlink" href="#edu_text_spliter" title="Permanent link">&para;</a></h2>
<p>将解析得到的长文本切分成适合向量化和检索的小块是 RAG 流程中的关键一步。本系统提供了两种文本切分工具。</p>
<h3 id="edu_chinese_recursive_text_splitterpy">中文递归文本切分器 (edu_chinese_recursive_text_splitter.py)<a class="headerlink" href="#edu_chinese_recursive_text_splitterpy" title="Permanent link">&para;</a></h3>
<p><code>ChineseRecursiveTextSplitter</code> 类是针对中文文本特点定制的切分器。</p>
<ul>
<li><strong>功能</strong>: 将长文本按照预设的中文分隔符递归地切分成指定大小的块。</li>
</ul>
<ul>
<li><strong>继承</strong>: <code>langchain.text_splitter.RecursiveCharacterTextSplitter</code>。</li>
</ul>
<ul>
<li><strong>核心定制</strong>: <ul>
<li><code>_separators</code>: 定义了用于切分的、按优先级排列的分隔符列表，包括常见的中文标点和换行符，如 <code>["\n\n", "\n", "。|！|？", "\.\s|\!\s|\?\s", "；|;\s", "，|,\s"]</code>。这有助于在切分时尽量保持句子的完整性。</li>
<li>支持通过正则表达式定义分隔符 (<code>is_separator_regex=True</code>)。</li>
<li>通过 <code>chunk_size</code> 和 <code>chunk_overlap</code> 控制切分块的大小和重叠。</li>
</ul>
</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="c1"># edu_text_spliter/edu_chinese_recursive_text_splitter.py 源码</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Any</span>
<span class="kn">from</span> <span class="nn">langchain.text_splitter</span> <span class="kn">import</span> <span class="n">RecursiveCharacterTextSplitter</span>
<span class="kn">import</span> <span class="nn">logging</span>

<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_split_text_with_regex_from_end</span><span class="p">(</span>
        <span class="n">text</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">separator</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">keep_separator</span><span class="p">:</span> <span class="nb">bool</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
    <span class="c1"># Now that we have the separator, split the text</span>
    <span class="k">if</span> <span class="n">separator</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">keep_separator</span><span class="p">:</span>
            <span class="c1"># The parentheses in the pattern keep the delimiters in the result.</span>
            <span class="n">_splits</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;(</span><span class="si">{</span><span class="n">separator</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span>
            <span class="n">splits</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">_splits</span><span class="p">[</span><span class="mi">0</span><span class="p">::</span><span class="mi">2</span><span class="p">],</span> <span class="n">_splits</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">])]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">_splits</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">splits</span> <span class="o">+=</span> <span class="n">_splits</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">:]</span>
            <span class="c1"># splits = [_splits[0]] + splits</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">splits</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">separator</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">splits</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">splits</span> <span class="k">if</span> <span class="n">s</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span><span class="p">]</span>


<span class="k">class</span> <span class="nc">ChineseRecursiveTextSplitter</span><span class="p">(</span><span class="n">RecursiveCharacterTextSplitter</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">separators</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">keep_separator</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
            <span class="n">is_separator_regex</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Create a new TextSplitter.&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">keep_separator</span><span class="o">=</span><span class="n">keep_separator</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_separators</span> <span class="o">=</span> <span class="n">separators</span> <span class="ow">or</span> <span class="p">[</span>
            <span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="s2">&quot;。|！|？&quot;</span><span class="p">,</span>
            <span class="s2">&quot;\.\s|\!\s|\?\s&quot;</span><span class="p">,</span>
            <span class="s2">&quot;；|;\s&quot;</span><span class="p">,</span>
            <span class="s2">&quot;，|,\s&quot;</span>
        <span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_is_separator_regex</span> <span class="o">=</span> <span class="n">is_separator_regex</span>

    <span class="k">def</span> <span class="nf">_split_text</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">separators</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Split incoming text and return chunks.&quot;&quot;&quot;</span>
        <span class="n">final_chunks</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># Get appropriate separator to use</span>
        <span class="n">separator</span> <span class="o">=</span> <span class="n">separators</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">new_separators</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">_s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">separators</span><span class="p">):</span>
            <span class="n">_separator</span> <span class="o">=</span> <span class="n">_s</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_separator_regex</span> <span class="k">else</span> <span class="n">re</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="n">_s</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">_s</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
                <span class="n">separator</span> <span class="o">=</span> <span class="n">_s</span>
                <span class="k">break</span>
            <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">_separator</span><span class="p">,</span> <span class="n">text</span><span class="p">):</span>
                <span class="n">separator</span> <span class="o">=</span> <span class="n">_s</span>
                <span class="n">new_separators</span> <span class="o">=</span> <span class="n">separators</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]</span>
                <span class="k">break</span>

        <span class="n">_separator</span> <span class="o">=</span> <span class="n">separator</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_separator_regex</span> <span class="k">else</span> <span class="n">re</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="n">separator</span><span class="p">)</span>
        <span class="n">splits</span> <span class="o">=</span> <span class="n">_split_text_with_regex_from_end</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">_separator</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_keep_separator</span><span class="p">)</span>

        <span class="c1"># Now go merging things, recursively splitting longer texts.</span>
        <span class="n">_good_splits</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">_separator</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_keep_separator</span> <span class="k">else</span> <span class="n">separator</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">splits</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_length_function</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_chunk_size</span><span class="p">:</span>
                <span class="n">_good_splits</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">_good_splits</span><span class="p">:</span>
                    <span class="n">merged_text</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_merge_splits</span><span class="p">(</span><span class="n">_good_splits</span><span class="p">,</span> <span class="n">_separator</span><span class="p">)</span>
                    <span class="n">final_chunks</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">merged_text</span><span class="p">)</span>
                    <span class="n">_good_splits</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">new_separators</span><span class="p">:</span>
                    <span class="n">final_chunks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">other_info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_split_text</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">new_separators</span><span class="p">)</span>
                    <span class="n">final_chunks</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">other_info</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">_good_splits</span><span class="p">:</span>
            <span class="n">merged_text</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_merge_splits</span><span class="p">(</span><span class="n">_good_splits</span><span class="p">,</span> <span class="n">_separator</span><span class="p">)</span>
            <span class="n">final_chunks</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">merged_text</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\n{2,}&quot;</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">chunk</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span> <span class="k">for</span> <span class="n">chunk</span> <span class="ow">in</span> <span class="n">final_chunks</span> <span class="k">if</span> <span class="n">chunk</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">!=</span><span class="s2">&quot;&quot;</span><span class="p">]</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">text_splitter</span> <span class="o">=</span> <span class="n">ChineseRecursiveTextSplitter</span><span class="p">(</span>
        <span class="n">keep_separator</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">is_separator_regex</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">chunk_size</span><span class="o">=</span><span class="mi">150</span><span class="p">,</span>
        <span class="n">chunk_overlap</span><span class="o">=</span><span class="mi">10</span>
    <span class="p">)</span>
    <span class="n">ls</span> <span class="o">=</span> <span class="p">[</span>
        <span class="sd">&quot;&quot;&quot;中国对外贸易形势报告（75页）。前 10 个月，一般贸易进出口 19.5 万亿元，增长 25.1%， 比整体进出口增速高出 2.9 个百分点，占进出口总额的 61.7%，较去年同期提升 1.6 个百分点。其中，一般贸易出口 10.6 万亿元，增长 25.3%，占出口总额的 60.9%，提升 1.5 个百分点；进口8.9万亿元，增长24.9%，占进口总额的62.7%， 提升 1.8 个百分点。加工贸易进出口 6.8 万亿元，增长 11.8%， 占进出口总额的 21.5%，减少 2.0 个百分点。其中，出口增 长 10.4%，占出口总额的 24.3%，减少 2.6 个百分点；进口增 长 14.2%，占进口总额的 18.0%，减少 1.2 个百分点。此外， 以保税物流方式进出口 3.96 万亿元，增长 27.9%。其中，出 口 1.47 万亿元，增长 38.9%；进口 2.49 万亿元，增长 22.2%。前三季度，中国服务贸易继续保持快速增长态势。服务 进出口总额 37834.3 亿元，增长 11.6%；其中服务出口 17820.9 亿元，增长 27.3%；进口 20013.4 亿元，增长 0.5%，进口增 速实现了疫情以来的首次转正。服务出口增幅大于进口 26.8 个百分点，带动服务贸易逆差下降 62.9%至 2192.5 亿元。服 务贸易结构持续优化，知识密集型服务进出口 16917.7 亿元， 增长 13.3%，占服务进出口总额的比重达到 44.7%，提升 0.7 个百分点。 二、中国对外贸易发展环境分析和展望 全球疫情起伏反复，经济复苏分化加剧，大宗商品价格 上涨、能源紧缺、运力紧张及发达经济体政策调整外溢等风 险交织叠加。同时也要看到，我国经济长期向好的趋势没有 改变，外贸企业韧性和活力不断增强，新业态新模式加快发 展，创新转型步伐提速。产业链供应链面临挑战。美欧等加快出台制造业回迁计 划，加速产业链供应链本土布局，跨国公司调整产业链供应 链，全球双链面临新一轮重构，区域化、近岸化、本土化、 短链化趋势凸显。疫苗供应不足，制造业“缺芯”、物流受限、 运价高企，全球产业链供应链面临压力。 全球通胀持续高位运行。能源价格上涨加大主要经济体 的通胀压力，增加全球经济复苏的不确定性。世界银行今年 10 月发布《大宗商品市场展望》指出，能源价格在 2021 年 大涨逾 80%，并且仍将在 2022 年小幅上涨。IMF 指出，全 球通胀上行风险加剧，通胀前景存在巨大不确定性。&quot;&quot;&quot;</span><span class="p">,</span>
        <span class="p">]</span>
    <span class="c1"># text = &quot;&quot;&quot;&quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">inum</span><span class="p">,</span> <span class="n">text</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ls</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">inum</span><span class="p">)</span>
        <span class="n">chunks</span> <span class="o">=</span> <span class="n">text_splitter</span><span class="o">.</span><span class="n">split_text</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">chunk</span> <span class="ow">in</span> <span class="n">chunks</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">chunk</span><span class="p">)</span>
</code></pre></div>
<h3 id="edu_model_text_spliterpy">基于模型的语义切分器 (edu_model_text_spliter.py)<a class="headerlink" href="#edu_model_text_spliterpy" title="Permanent link">&para;</a></h3>
<p><code>AliTextSplitter</code> 类提供了另一种基于 AI 模型的文本切分方法。</p>
<ul>
<li><strong>功能</strong>: 利用预训练的文档语义分割模型对文本进行切分。</li>
</ul>
<ul>
<li><strong>继承</strong>: <code>langchain.text_splitter.CharacterTextSplitter</code>。</li>
</ul>
<ul>
<li><strong>核心逻辑</strong>: <ol>
<li>初始化时指定是否处理 PDF 文本（包含特定的换行符和空格处理逻辑）。</li>
<li>调用 <code>modelscope.pipeline</code> 加载指定的文档分割模型（代码中为 <code>MODEL_PATH['segment_model']['ali_model']</code>，需要配置 <code>configs.py</code> 或直接指定模型路径/名称，如 'damo/nlp_bert_document-segmentation_chinese-base'）。模型运行在 CPU 上。</li>
<li>将输入文本传递给模型 pipeline 进行处理。</li>
<li>模型返回按语义分割好的文本段落，脚本将其整理成列表返回。</li>
</ol>
</li>
</ul>
<ul>
<li><strong>优势</strong>: 理论上能更好地根据内容的语义关联性进行切分，而不是仅仅依赖标点符号。</li>
</ul>
<ul>
<li><strong>劣势</strong>: 需要额外加载一个模型，增加了计算开销和依赖。</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="c1"># edu_text_spliter/edu_model_text_spliter.py 源码</span>
<span class="kn">from</span> <span class="nn">langchain.text_splitter</span> <span class="kn">import</span> <span class="n">CharacterTextSplitter</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span>
<span class="kn">from</span> <span class="nn">modelscope.pipelines</span> <span class="kn">import</span> <span class="n">pipeline</span>
<span class="c1"># from configs import MODEL_PATH # Assume MODEL_PATH is defined elsewhere or replaced</span>


<span class="c1"># Placeholder for MODEL_PATH if configs.py is not available</span>
<span class="n">MODEL_PATH</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;segment_model&#39;</span><span class="p">:</span> <span class="p">{</span>
        <span class="c1"># Replace with the actual model name or path from ModelScope</span>
        <span class="s1">&#39;ali_model&#39;</span><span class="p">:</span> <span class="s1">&#39;damo/nlp_bert_document-segmentation_chinese-base&#39;</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="k">class</span> <span class="nc">AliTextSplitter</span><span class="p">(</span><span class="n">CharacterTextSplitter</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pdf</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pdf</span> <span class="o">=</span> <span class="n">pdf</span>
        <span class="c1"># Initialize the pipeline here or ensure it&#39;s initialized before split_text is called</span>
        <span class="c1"># Consider adding error handling for model loading</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pipeline</span> <span class="o">=</span> <span class="n">pipeline</span><span class="p">(</span>
                <span class="n">task</span><span class="o">=</span><span class="s2">&quot;document-segmentation&quot;</span><span class="p">,</span>
                <span class="n">model</span><span class="o">=</span><span class="n">MODEL_PATH</span><span class="p">[</span><span class="s1">&#39;segment_model&#39;</span><span class="p">][</span><span class="s1">&#39;ali_model&#39;</span><span class="p">],</span>
                <span class="n">device</span><span class="o">=</span><span class="s2">&quot;cpu&quot;</span> <span class="c1"># Specify CPU device</span>
            <span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error initializing ModelScope pipeline: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pipeline</span> <span class="o">=</span> <span class="kc">None</span>


    <span class="k">def</span> <span class="nf">split_text</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">pipeline</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;ModelScope pipeline not initialized. Returning empty list.&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">[]</span>

        <span class="c1"># Preprocessing specific to PDF text if needed</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pdf</span><span class="p">:</span>
            <span class="n">text</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\n{3,}&quot;</span><span class="p">,</span> <span class="sa">r</span><span class="s2">&quot;\n&quot;</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span>
            <span class="c1"># Replace multiple spaces with a single space</span>
            <span class="n">text</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s1">&#39;\s+&#39;</span><span class="p">,</span> <span class="s2">&quot; &quot;</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span>
            <span class="c1"># Consider removing single newlines carefully, might merge unrelated lines</span>
            <span class="c1"># text = text.replace(&quot;\n&quot;, &quot; &quot;) # This might be too aggressive</span>
            <span class="n">text</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span> <span class="c1"># Keep paragraph breaks</span>


        <span class="k">try</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pipeline</span><span class="p">(</span><span class="n">documents</span><span class="o">=</span><span class="n">text</span><span class="p">)</span>
            <span class="c1"># The default output format might be a single string with &quot;\n\t&quot; separators</span>
            <span class="n">sent_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">segment</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="k">for</span> <span class="n">segment</span> <span class="ow">in</span> <span class="n">result</span><span class="p">[</span><span class="s2">&quot;text&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\t</span><span class="s2">&quot;</span><span class="p">)</span> <span class="k">if</span> <span class="n">segment</span><span class="o">.</span><span class="n">strip</span><span class="p">()]</span>
            <span class="k">return</span> <span class="n">sent_list</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error during ModelScope document segmentation: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="c1"># Fallback behavior: maybe split by paragraph or return the original text in a list</span>
            <span class="k">return</span> <span class="n">text</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n\n</span><span class="s1">&#39;</span><span class="p">)</span> <span class="c1"># Simple fallback</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="c1"># Example usage requires modelscope and relevant model downloaded</span>
    <span class="c1"># pip install &quot;modelscope[nlp]&quot; tensorflow torch -f https://modelscope.oss-cn-beijing.aliyuncs.com/releases/repo.html</span>

    <span class="n">sample_text</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;移动端语音唤醒模型，检测关键词为“小云小云”。</span>
<span class="s2">模型主体为4层FSMN结构，使用CTC训练准则，参数量750K，适用于移动端设备运行。</span>

<span class="s2">模型输入为Fbank特征，输出为基于char建模的中文全集token预测，测试工具根据每一帧的预测数据进行后处理得到输入音频的实时检测结果。</span>
<span class="s2">模型训练采用“basetrain + finetune”的模式，basetrain过程使用大量内部移动端数据，在此基础上，使用1万条设备端录制安静场景“小云小云”数据进行微调，得到最终面向业务的模型。</span>
<span class="s2">后续用户可在basetrain模型基础上，使用其他关键词数据进行微调，得到新的语音唤醒模型，但暂时未开放模型finetune功能。&quot;&quot;&quot;</span>

    <span class="c1"># Assuming MODEL_PATH is correctly configured and modelscope is installed</span>
    <span class="n">model_split</span> <span class="o">=</span> <span class="n">AliTextSplitter</span><span class="p">()</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">model_split</span><span class="o">.</span><span class="n">split_text</span><span class="p">(</span><span class="n">text</span><span class="o">=</span><span class="n">sample_text</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
    <span class="c1"># Expected output (example, actual output depends on the model):</span>
    <span class="c1"># [&#39;移动端语音唤醒模型，检测关键词为“小云小云”。&#39;, &#39;模型主体为4层FSMN结构，使用CTC训练准则，参数量750K，适用于移动端设备运行。&#39;, &#39;模型输入为Fbank特征，输出为基于char建模的中文全集token预测，测试工具根据每一帧的预测数据进行后处理得到输入音频的实时检测结果。&#39;, &#39;模型训练采用“basetrain + finetune”的模式，basetrain过程使用大量内部移动端数据，在此基础上，使用1万条设备端录制安静场景“小云小云”数据进行微调，得到最终面向业务的模型。&#39;, &#39;后续用户可在basetrain模型基础上，使用其他关键词数据进行微调，得到新的语音唤醒模型，但暂时未开放模型finetune功能。&#39;]</span>
</code></pre></div>
<h3 id="_3">本章总结<a class="headerlink" href="#_3" title="Permanent link">&para;</a></h3>
<p>本章我们详细介绍了 EduRAG 系统中用于处理原始文档和切分文本的核心工具。在文档解析方面，我们学习了 <code>edu_document_loaders</code> 目录下的各个加载器如何利用 <code>PyMuPDF</code>, <code>python-docx</code>, <code>python-pptx</code> 等库结合 <code>RapidOCR</code>（通过 <code>edu_ocr.py</code> 提供）来处理 PDF、DOCX、PPTX 及图像文件，有效提取文本和图片中的文字。在文本切分方面，我们探讨了 <code>edu_text_spliter</code> 目录提供的两种工具：<code>ChineseRecursiveTextSplitter</code>（针对中文优化的、基于规则的递归切分器）和 <code>AliTextSplitter</code>（利用 AI 模型进行语义切分）。理解这些底层工具的功能和实现是掌握 RAG 系统数据处理流程的关键。</p>





                
              </article>
            </div>
          
          
        </div>
        
      </main>
      
        <footer class="md-footer">
  
    
    <nav class="md-footer__inner md-grid" aria-label="页脚" >
      
        
        <a href="07-RAG%E7%B3%BB%E7%BB%9F%E8%BF%90%E8%A1%8C.html" class="md-footer__link md-footer__link--prev" aria-label="上一页: 4.7 RAG系统运行" rel="prev">
          <div class="md-footer__button md-icon">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
          </div>
          <div class="md-footer__title">
            <div class="md-ellipsis">
              <span class="md-footer__direction">
                上一页
              </span>
              4.7 RAG系统运行
            </div>
          </div>
        </a>
      
      
        
        <a href="../%E7%AC%AC%E4%BA%94%E7%AB%A0%EF%BC%9ARAG%E7%B3%BB%E7%BB%9F%E8%AF%84%E4%BC%B0/01-RAG%E7%B3%BB%E7%BB%9F%E8%AF%84%E4%BC%B0%E5%B7%A5%E5%85%B7.html" class="md-footer__link md-footer__link--next" aria-label="下一页: 5.1 RAG系统评估工具" rel="next">
          <div class="md-footer__title">
            <div class="md-ellipsis">
              <span class="md-footer__direction">
                下一页
              </span>
              5.1 RAG系统评估工具
            </div>
          </div>
          <div class="md-footer__button md-icon">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M4 11v2h12l-5.5 5.5 1.42 1.42L19.84 12l-7.92-7.92L10.5 5.5 16 11H4Z"/></svg>
          </div>
        </a>
      
    </nav>
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    <script id="__config" type="application/json">{"base": "..", "features": [], "search": "../assets/javascripts/workers/search.16e2a7d4.min.js", "translations": {"clipboard.copied": "\u5df2\u590d\u5236", "clipboard.copy": "\u590d\u5236", "search.config.lang": "ja", "search.config.pipeline": "trimmer, stemmer", "search.config.separator": "[\\s\\-\uff0c\u3002]+", "search.placeholder": "\u641c\u7d22", "search.result.more.one": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.more.other": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 # \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.none": "\u6ca1\u6709\u627e\u5230\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.one": "\u627e\u5230 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.other": "# \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.placeholder": "\u952e\u5165\u4ee5\u5f00\u59cb\u641c\u7d22", "search.result.term.missing": "\u7f3a\u5c11", "select.version.title": "\u9009\u62e9\u5f53\u524d\u7248\u672c"}}</script>
    
    
      <script src="../assets/javascripts/bundle.5a2dcb6a.min.js"></script>
      
        <script src="../js/extra.js"></script>
      
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML"></script>
      
    
    
  </body>
</html>