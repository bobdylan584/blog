---
title: 大模型微调的主要方式
date: 2024-03-30 08:19:54
tag: FineTuningNotes
---

# 大模型微调的主要方式【掌握】

## 1、大模型Prompt-Tuning方法

### 1.1 NLP任务四种范式

- 第一范式：基于传统机器学习模型
- 第二范式：基于深度学习
- 第三范式：基于预训练模型+fine-tuning
- 第四范式：预训练模型+Prompt+预测

### 1.2 Fine-Tuning(微调)

Fine-Tuning基本思想：使用小规模的特定任务文本继续训练预训练语言模型。

Fine-Tuning问题：

- 所需的Fine-Tuning量取决于预训练语料库和任务特定语料库之间的相似性。如果两者相似，可能只需要少量的Fine-Tuning，如果两者不相似，则可能需要更多的Fine-Tuning，并且效果不明显。
- 成本高



Prompt-Tuning的基本思想：通过添加模板的方法将任务目标转化为与预训练目标相似的形式（如MLM），避免引入额外的参数的同时，最大化利用模型的预训练知识。

Prompt-Tuning主要解决传统Fine-Tuning方式的两个痛点：

- **降低语义偏差：**预训练任务主要以MLM为主，而下游任务则重新引入新的训练参数，因此两个阶段目标差异较大。因此需要解决Pre-Training和Fine-Tuning之间的Gap。
- **避免过拟合：**由于Fine-Tuning阶段需要引入新的参数适配相应任务，因此在样本数量有限的情况下容易发生过拟合，降低模型泛化能力。因此需要解决预训练模型的过拟合能力。 



### 1.3 Prompt-Tuning(提示微调)

（1）什么是Prompt?

即提示词

（2）Prompt-Tuing的本质

Fine-Tuning的本质：==调整预训练模型，让预训练模型去迁就下游任务。==

Prompt-Tuing的本质：==让下游任务去迁就预训练模型，将Fine-tuning的下游任务目标转换为Pre-training的任务。==



（3）Fine-Tuning和Prompt-Tuing对比

| 特征         | Fine-tuning (模型迁就任务)                                   | Prompt Tuning (任务迁就模型)                                 |
| ------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **核心操作** | **修改**预训练模型的参数，使其适应下游任务的数据和目标       | 调整少量参数（如软提示向量）或仅依赖输入设计（提示工程）     |
| **模型状态** | **发生变化**，学习新的特定任务知识                           | **保持不变**，利用已有的通用知识                             |
| **任务目标** | 直接学习下游任务的特定目标函数                               | 将下游任务目标**重构**为预训练模型更擅长的形式（如生成、补全） |
| **资源消耗** | 通常需要**大量计算资源**进行训练，为每个任务存储一个模型副本 | **计算资源消耗极少**，只需存储和处理 Prompt                  |
| **目的**     | **深度适应**特定任务，可能牺牲通用性，但通常性能上限高       | **高效利用**预训练模型的通用能力，在资源有限时效果显著，泛化性好 |



### 1.4 Prompt-Tuning技术发展历程

![1-3-8](1-3-8.png)



### 1.5 面向超大规模语言模型的Prompt-Tuning

特点：模型的 **参数量足够大**，训练过程中使用了**足够多的语料**，同时设计的**预训练任务足够有效**。

效果：只需要设计合适的模板或指令即可以**实现免参数训练的零样本学习** 。

类型：

- In-Context Learning（上下文学习）：通过上下文示例（demonstrations）让模型理解任务，而**无需显式训练**。
- Instruction-Tuning（指令微调）：在已有的预训练语言模型基础上，收集大量的成对数据（指令，期望输出），对模型进行额外的**监督微调**，让它学会遵循人类自然语言指令完成任务。
- Chain-of-Thought（思维链）：一种改进的提示策略，用于提高 LLM 在复杂推理任务中的性能。**方法就是相比于之前的上下文学习多了中间的推导过程提示。**



### 1.6 面向小规模语言模型的Prompt-Tuning

#### 1.6.1 Prompt-Tuning的鼻祖—PET模型

（1）PET模型的核心思想：==将下游任务重构为预训练模型最熟悉的“完形填空”问题，从而利用语言模型对文本的理解能力，最终通过少量示例训练获得较好的下游性能。==

（2）方法：通过设计自然语言模式（pattern）和标签词映射（verbalizer），将输入句子转换为带有[MASK]位置的文本，例如“这个电影很[MASK]。”，然后用预训练语言模型（如BERT）预测[MASK]位置的词，再通过verbalizer转换来完成分类任务。

![image-20250814224811173](image-20250814224811173.png)

（3）PVP组件

- **Pattern（Template）** ：记作T，为额外添加的带有`[mask]`标记的短文本，用于引出不同任务的预测词。
- **Verbalizer** ：记作V, 即标签词的映射，对于具体的分类任务，需要选择指定的标签词（label word）。



（4）人工设计PVP的缺陷

- 采用人工构建的方法成本高，需要与领域任务相关的先验知识
- 人工设计的Pattern和Verbalizer不能保证获得最优解，训练不稳定，不同的PVP对结果产生的差异明显，方差大
- 人工构建的Pattern和Verbalizer使得Prompt-Tuning与MLM在语义和分布上依然存在差异



#### 1.6.2 Prompt-Oriented Fine-Tuning

（1）本质：**本将目标任务转换为适应预训练模型的预训练任务，以适应预训练模型的学习体系。**

（2）类型

根据提示的类型不同，POFT方法主要分成三种类型：

- 离散提示：也叫硬模版，其提示是由真实的自然语言单词或符号组成，直接拼接到输入中。
- 连续提示：==也叫软模板，提示不是实际的单词，而是**可训练的向量**，插入到输入 embedding 序列中。==
- 混合提示：同时使用**人工可读的离散 token**和**可训练的连续向量**。

按照训练时参数更新的范围不同，POFT方法主要分成三种类型：

- 全量微调（Full Fine-Tuning）：模型所有参数都参与更新，包括预训练模型参数和下游任务层参数。如PET模型。
- 部分参数微调（Partial Fine-Tuning）：只更新预训练模型中的一部分参数，比如高层 transformer block、某些 attention 层或特定模块，其余参数冻结。如Adapter Tuning。
- 仅提示参数微调（Prompt-Only Tuning）：==冻结原始预训练模型参数，只训练 prompt 参数。如P-tuning、Prompt Tuning等==。

（3）PET中使用的POFT：==硬模板+ 全量微调==

全量微调：成本高，要求数据量大

硬模版：人工构建成本高、不同PVP对结果产生的差异明显、与MLM训练任务不完全一致



#### 1.6.3 Soft Prompt及微调方法

##### 1.6.3.1 连续提示模板

Soft Prompt (连续提示) ：是指通过给模型输入一个可参数化的提示模板，从而引导模型生成符合特定要求的文本。

特点：

- 将模板变为可训练的参数，不同的样本可以在连续的向量空间中寻找合适的伪标记，同时也增加模型的泛化能力。
- 连续法需要引入少量的参数并在训练时进行参数更新，但预训练模型参数是不变的，变的是prompt token对应的词向量（Word Embedding）表征及其他引入的少量参数。

##### 1.6.3.2 Prompt Tuning（NLG任务）

（1）方法：为每一个输入文本假设一个固定前缀提示，该提示表由神经网络参数化，并在下游任务微调时进行更新，整个过程中预训练的大模型参数被冻结。

![image-20250818154810642](image-20250818154810642.png)

（2）特点

- 优点：
    - 大模型的微调新范式
    - 模型参数规模大了之后，可以将大模型参数固定，指定附加参数来适配下游任务，而且适配性能基本和全参数微调相当。
- 缺点：
    - 在小样本学习场景上表现不太行
    - 收敛速度比较慢
    - 调参比较复杂

##### 1.6.3.3 P-tuning（NLU任务）

（1）P-tuning 的核心思想是：用一个小的可训练模块把一组“连续提示向量”生成并插入到原始输入 embedding 中，令**冻结的预训练模型**在下游任务上产生正确输出，训练时仅更新 prompt encoder（或提示向量），从而实现低成本高效的调优。

![image-20250818163852423](image-20250818163852423.png)

（2）**P-tuning的特点**：

- 优点：
    - 引入了一个 LSTM +MLP模块对 soft prompt 进行建模，能捕捉 token 之间的顺序和语义关系
    - 改进了离散 prompt的不稳定性问题，收敛速度更快
- 缺点
    - 仅放在输入层时，对模型内部深层表征的影响有限，面对一些需要深层表示调整的 NLU/序列标注任务表现并不稳定或不足
    - 在中小模型（100M–1B）表现较差

（3）**P-Tuning v2的核心思想**：在模型的每一层都应用连续的 prompts 并对 prompts 参数进行更新优化

![img](1-3-9.png)

注意：P-Tuning v2中，在一些任务中，引入一个重参数化的编码器（如MLP，多层感知机）可以对提示向量进行非线性变换，提升模型性能。但是，研究发现其效果因任务而异，因此在P-Tuning v2中，是否使用重参数化需要根据具体任务进行选择。

- 使用重参数化：使用MLP对前缀嵌入进行转换（对应于Prefix-Tuning）
- 不使用重参数化：直接使用前缀嵌入（对应于P-Tuning v2）

（4）**P-tuning v2的特点**：

- 优点：
    - 把 soft prompts 注入每层，能在多种规模与任务上接近全量微调效果
- 缺点
    - 深层 prompt 或长 soft prompt 会占用较多 token / 输入空间
    - P-tuning 的 soft prompt 是针对每个下游任务独立训练的，无法直接迁移到其他任务上使用

（5）**P-tuning v1与P-tuning v2对比**

| 对比        维度 | **P-tuning v1**                                              | **P-tuning v2**                                              |
| ---------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **提出时间**     | 2021（原始 P-tuning）                                        | 2022（P-tuning v2）                                          |
| **核心思路**     | 在输入 embedding 层前插入连续可训练的 **prompt embeddings**，通过 LSTM/MLP 对伪标记编码，优化这些参数以适配下游任务 | 在 **Transformer 每一层** 注入可训练的 **layer-wise prompts**（类似 prefix-tuning），直接与各层隐状态交互 |
| **插入位置**     | 仅作用于 **embedding 层**（输入端）                          | 作用于 **每一层 Transformer**（layer-wise prompt）           |
| **参数规模**     | 较少（仅输入 prompt 参数）                                   | 略多于 v1（每层都有 prompt 参数），但仍远小于全量微调        |
| **表达能力**     | 容易受限，难以在小数据任务中获得与全量微调接近的性能         | 表达能力更强，性能更接近甚至超越全量微调                     |
| **训练方式**     | 仅优化 prompt encoder 参数，其余预训练模型参数冻结           | 冻结预训练模型主干，优化每层的 prompt 参数                   |
| **初始化方式**   | 通常从 vocab embedding 随机或用任务相关词初始化              | 通常随机初始化，也可借助任务先验初始化                       |
| **依赖组件**     | 需要 **Prompt Encoder**（如 LSTM/MLP）来生成连续模板向量     | 不需要复杂 Prompt Encoder，直接将可训练向量作为 prefix 注入每层 |
| **优点**         | 参数量小、实现简单、易迁移到不同任务                         | 表达能力强、在低资源场景下性能稳定、接近全量微调效果         |
| **缺点**         | 对复杂任务适配能力不足，深层信息利用不充分                   | 参数量稍大，实现比 v1 复杂，需要改造模型结构                 |
| **适用场景**     | 对计算资源和任务复杂度要求低的场景                           | 更复杂、对性能要求高或低资源任务中替代全量微调               |



##### 1.6.3.4 PPT（Pre-trained Prompt Tuning）

（1）PPT 的核心思想：对连续提示模板也进行预训练——先让这些连续提示在大量无标注的预训练语料进行预训练（注意，预训练过程中，Pre-train-model参数固定不变，只改变soft prompt），然后将其加载到对应下游任务的PLM上进行微调后使用。

![image-20250818173316706](image-20250818173316706.png)



（2）**PPT的特点**：

- 优点：
    - 预训练soft-prompt带来了 小样本学习场景上的显著提升
    - 缓解了prompt-tuning收敛慢的问题
- 缺点
    - 高度依赖于源任务集的覆盖度与多样性(一旦目标任务与预训练时用到的源任务在分布、格式或语义上差异较大，通用提示 𝑃就难以提供有效的初始引导，导致下游微调效果大幅下降)



## 2、大模型PEFT微调方法【掌握】

（1）参数高效微调方法（Parameter-Efficient Fine-Tuning，PEFT）特点：

- **PEFT 方法仅微调少量或额外的模型参数，固定大部分预训练参数，大大降低了计算和存储成本**

- **最先进的 PEFT 技术也能实现了与全量微调相当的性能**

（2）类型

- **Prefix/Prompt-Tuning**：在模型的输入或隐层添加 $k$个额外可训练的前缀 tokens（这些前缀是连续的伪 tokens，不对应真实的 tokens），只训练这些前缀参数；
- **Adapter-Tuning**：将较小的神经网络层或模块插入预训练模型的每一层，这些新插入的神经模块称为 adapter（适配器），下游任务微调时也只训练这些适配器参数；
- **LoRA**：通过学习小参数的低秩矩阵来近似模型权重矩阵 $W$的参数更新，训练时只优化低秩矩阵参数。



### 2.1 Prefix Tuning

（1）做法：在模型的输入或隐层添加 $k$个额外可训练的前缀 tokens（这些前缀是连续的伪 tokens，不对应真实的 tokens），只训练这些前缀参数

（2）具体实现流程如下：

1）**确定任务与基模型**

- 任务：条件生成（如摘要、表格到文本、对话）或 seq2seq。
- 选模型：GPT-2/decoder-only 或 BART/T5（encoder-decoder）。

2）**设计 prefix 配置**

- 决定 `num_prefix`（每层的虚拟 token 数，常见 10–100），以及是否对所有层都使用 prefix（论文对每层都用了 prefix，但可做只对部分层）。

3）**构造可训练参数（初始化）**

原始论文中为每层创建一个可以训练的矩阵$P_θ$ ，作为前缀向量拼接到原向量中。但是论文中提出直接优化 $P_θ$ 会导致训练不稳定，可以通过一个更小的矩阵 $P_w$和一个更大的前馈神经网络$MLP_θ$ 对$P_θ$ 进行重参数化: $P_θ[i,:]=MLP_θ(P_w[i,:])$ 。

所以目前实际实现时，通常会先训练一个 `(num_layers, num_prefix, hidden_dim)` 的 prefix embedding，然后通过一个小的 MLP 投影成 `(num_layers, num_prefix, 2 * head_dim * num_heads)`，再 reshape 成 `(num_layers, num_heads, num_prefix, head_dim)`，分别拆成 K 和 V。因此需要创建一个可训练的矩阵 $P_θ$  ，以及一个MLP模型。

4）**修改模型前向（插入 prefix）**

- 在 Transformer 的每一层注意力里，将 prefix 对应的 key/value 拼接到原始的 key/value——这样后续 token 可以像“看到真实 tokens”一样 attend 到 prefix，然后一起进行训练。

5）**训练设置**

- 冻结原模型参数（`requires_grad=False`），只对 prefix 参数做优化。
- 损失函数通常是标准的交叉熵，训练器只更新 prefix。 

6）**推理**

- 推理时把训练好的 prefix 附加到每层（同训练时），然后用常见的解码策略进行生成。



（3）**Prefix Tuning的特点**：

- 优点：
    - 只训练少量 prefix 参数，相对全量微调的存储和训练成本低。
    - 不同任务只需切换 prefix，无需保存多个完整模型。
- 缺点
    - 小模型表现差：在 BERT-base 等小模型上效果不佳
    - 需在每层注入 prefix，会占用输入序列的长度
    - 在判别式任务上常逊于 LoRA、P-Tuning v2



（4）Prefix Tuning与P-Tuning v1和v2的区别

1）**目标任务**

- Prefix-Tuning：主要面向**生成类任务**（table→text、summarization、GPT-2/BART 等场景），论文强调在生成上用少量参数达到接近微调的效果。

- P-Tuning v1和v2：主要针对**NLU（分类、序列标注、QA 等）**，目标是让 prompt-only 方法在 NLU 上也能普遍接近微调的性能。

2）**注入位置**

- P-tuning v1：只在输入 embedding 处（相当于在输入序列前加若干soft prompt 的 embedding）。
- Prefix Tuning / P-tuning v2：在 Transformer 每一层的中都进行注入。

3）**注入形式**

- Prefix Tuning：将前缀token直接作用到注意力机制计算的 ==key/value==上，然后进行注意力计算。

- P-tuning v1和P-tuning v2都是将原始embedding+prompt embedding组成的新输入后送入下一层。工程上有人后来把 P-Tuning v2 改成 KV 注入形式（同Prefix Tuning形式）以提高效率。

4）**参数化方式**

- Prefix Tuning：原始论文中直接优化每层的“past key/value”向量（通常把这些向量当作要学习的参数矩阵）；另外，也提出生成一个初始向量，再通过MLP进行投影效果更好。
- P-tuning v1：通过 prompt encoder优化一组输入级别的 embedding。
- P-tuning v2：提出了可选的 reparameterization（用小网络如MLP把少量可训练参数映射成每层的完整 prompt），利于参数共享、稳定训练并在层数很多时控制参数量。如果不用reparameterization则直接使用embedding的结果。

5）**效果**

- P-tuning v1：对 decoder-only、encoder-decoder 都可用，但效果和适用性有限（因为只在输入层）。
- Prefix Tuning 与 P-tuning v2：更适合需要深层修改注意力的信息流的任务（对 decoder-only 和 encoder-decoder 都能做扩展，且在很多任务上性能更好）。



### 2.2 Adapter Tuning

（1）做法：在预训练模型内部的网络层之间添加新的网络层或模块来适配下游任务

（2）Series Adapter的适配器结构和与 Transformer 的集成结构：

![image-20250818181655276](image-20250818181655276.png)

（3）**Adapter Tuning的特点**：

- 优点：
    - 只训练少量 adapter 参数，相对全量微调的存储和训练成本低。
    - 可以为多个任务保存不同的 adapter，而共享一个大模型。
    - 多个任务的 adapters 可以在推理时进行切换或融合，提升迁移和泛化能力。
- 缺点
    - 因为大部分参数被冻结，adapter 的容量有限，对复杂任务或需要大规模参数调整的任务可能效果不如全量微调。
    - Adapter 的维度大小（瓶颈层大小）、插入位置等超参数对性能影响较大，调参复杂度较高。
    -  PLM 基础上添加适配器层会引入额外的计算，带来推理延迟问题

### 2.3 LoRA

（1）补充知识——秩

- 1）什么叫做秩？

**矩阵中所有行向量（或列向量）所张成的向量空间的维数**。

换句话说，秩衡量了矩阵里有多少个 **线性无关的行/列**。如果把矩阵看成是很多向量的集合，那么秩就是这些向量中最多能取出的互不依赖的数量。

![image-20250816174459601](image-20250816174459601.png)

- 2）秩的几种等价定义

    - 行秩：矩阵中线性无关的行向量个数

    - 列秩：矩阵中线性无关的列向量个数

    - 基本定理：**行秩 = 列秩**，这个共同的数就是矩阵的秩。

- 3）秩的直观理解

秩 = 有效信息量，秩越高，矩阵包含的独立信息越多。

（2）做法：在预训练语言模型（PLM）的特定线性层（如自注意力机制中的 Q、K、V 投影层和前馈网络）旁边，并行地注入一对小的、可训练的低秩分解矩阵，而冻结 PLM 的原有参数。

低秩适应：对大型模型的权重矩阵进行隐式的低秩转换，也就是：通过一个较低维度的表示来近似表示一个高维矩阵或数据集。

（3）基本原理：LoRA技术冻结预训练模型的权重，并在每个Transformer块中注入可训练层（称为秩分解矩阵），即在模型的Linear层的旁边增加一个“旁支”A和B。其中，A将数据从d维降到r维，这个r是LoRA的秩，是一个重要的超参数；B将数据从r维升到d维，B部分的参数初始为0。模型训练结束后，需要将A+B部分的参数与原大模型的参数合并在一起使用。

![image-20250819103825320](image-20250819103825320.png)

（4）**LoRA的特点**：

- 优点：
    - 只训练极少参数，相对全量微调的存储和训练成本低。
    - 效果接近全参数微调，且保留原模型能力。
    - 不同任务的 LoRA 模块可插拔，便于多任务部署。
- 缺点
    - LoRA 本质是用低秩分解逼近权重更新矩阵，这对参数空间的表达能力有限制，可能无法拟合某些复杂任务所需的高秩变化。
    - LoRA 通常加在 attention 的投影矩阵（Wq/Wv）上，但不同任务可能对位置敏感，选择不好会影响性能。

### 2.4 QLoRA

（1）核心思想是：**通过对预训练语言模型（PLM）进行量化（通常是 4-bit NormalFloat），并结合 LoRA 技术进行微调，从而在极低的内存消耗下，仍然能够高效地微调巨型语言模型，同时保持甚至超越全量 16-bit LoRA 的性能。**

（2）核心创新点

- 高效低精度量化（NF4 量化）：NF4 采用了非均匀的数值分布映射，更好地保留了原始权重的细微差异，使得在极低精度下仍能保持接近 FP16 的模型性能。
- 采用双量化和分页优化器，进一步减少显存占用。
- 在量化后的冻结PLM上，**LoRA的微调机制保持不变**。

（3）**QLoRA的特点**

- 优点：
    - 极低的内存消耗。这是 QLoRA 最显著的优势。可以将训练巨型模型的内存需求降低 3-4 倍，使得在单张消费级 GPU 上（如 24GB VRAM 的 RTX 3090/4090）微调 65B 甚至 70B 参数的模型成为可能。
    - 性能优异：尽管进行了 4-bit 量化，但由于 16-bit 的 LoRA 权重和优化器状态，QLoRA 在许多任务上能够保持与 16-bit LoRA 甚至全量微调相媲美的性能。
    - 训练速度快：由于只训练少量参数且内存效率高，训练速度非常快。
- 缺点
    - 虽然 NF4 优化了精度，但极端任务或敏感任务可能仍受 4-bit 量化影响。
    - 由于量化和分页机制的存在，训练和问题调试会比标准 LoRA 更复杂。
