---
title: 面向对象进阶
date: 2023-07-07 10:28:14
tag: Python Advanced
---

## 子类重写父类的功能

```python
# 小明掌握了老师傅和黑马的技术后，
# 自己潜心钻研出一套自己的独门配方的全新摊煎饼果子技术。
"""
重写解释：
    概念：重写也叫覆盖，即子类出现和父类【重名】的属性或者方法 。称之为重写
    调用层次：就近原则 子类用子类的，没有就去找父类的，依次按照继承顺序去找其他父类
"""


class Master:
    def __init__(self):
        self.kongfu = "[古法煎饼果子配方]"

    def make_cake(self):
        print(f"运用{self.kongfu}制作煎饼果子")


class School:
    def __init__(self):
        self.kongfu = "[黑马AI煎饼果子配方]"

    def make_cake(self):
        print(f"运用{self.kongfu}制作煎饼果子")


class Prentice(School, Master):
    # 创新
    def __init__(self):
        self.kongfu = "[独创的煎饼果子配方]"

    def make_cake(self):
        print(f"运用{self.kongfu}制作煎饼果子")

xm=Prentice()
print(xm.make_cake())


```

## 子类访问父类功能

* 方式1: **父类名.父类功能名(self)**

  ![1741916481470](1741916481470.png)

  ```python
  """
  很多顾客都希望能吃到徒弟做出的有自己独立品牌的煎饼果子，
  也有黑马配方技术的煎饼果子味道。
  
  语法格式：
      1：父类名.父类函数名(self)   精准访问，想找哪个父类，就调用哪个父类
      2: super().父类函数名()      只能访问最近的那个父类，有就用，没有就继续往后找，找不到就报错
  """
  
  
  class Master:
      def __init__(self):
          self.kongfu = "[古法煎饼果子配方]"
      def make_cake(self):
          print(f"Master：运用{self.kongfu}制作煎饼果子")
  class School:
      def __init__(self):
          self.kongfu = "[黑马AI煎饼果子配方]"
      def make_cake(self):
          print(f"School：运用{self.kongfu}制作煎饼果子")
  class Prentice(School, Master):
      # 创新
      def __init__(self):
          self.kongfu = "[独创的煎饼果子配方]"
      def make_cake(self):
          print(f"运用{self.kongfu}制作煎饼果子")
  
      # 需求：同时满足 独创  &  古法
      def make_master_cake(self):
          School.__init__(self)  # 这里需要初始化父类的self。不然还会调用子类的self 打印独创
          Master.make_cake(self)
      def make_school_cake(self):
          Master.__init__(self)  # 这里需要初始化父类的self。不然还会调用子类的self 打印独创
          School.make_cake(self)
  p = Prentice()
  print(p.kongfu)  # 独创
  p.make_cake()  # 独创
  p.make_master_cake()  # 独创  古法？
  
  
  
  ```

* 方式2: **super().父类功能名()**

  ```python
  # 很多顾客都希望能吃到徒弟做出的有自己独立品牌的煎饼果子，
  # 也有黑马配方技术的煎饼果子味道。
  class Master:
      pass
      # def __init__(self):
      #     self.kongfu = "[古法煎饼果子配方]"
      # def make_cake(self):
      #     print(f"Master：运用{self.kongfu}制作煎饼果子")
  class School:
      pass
      # def __init__(self):
      #     self.kongfu = "[黑马AI煎饼果子配方]"
      # def make_cake(self):
      #     print(f"School：运用{self.kongfu}制作煎饼果子")
  class Prentice(Master,School):
      # 创新
      def __init__(self):
          self.kongfu = "[独创的煎饼果子配方]"
      def make_cake(self):
          print(f"运用{self.kongfu}制作煎饼果子")
  
      def make_old_cake(self):
          super().__init__()
          super().make_cake()
  
  p = Prentice()
  print(p.kongfu)
  p.make_cake()
  print("*"*24)
  p.make_old_cake()
  ```

## 封装入门

```python
# 小明把技术传承给徒弟的同时，不想把自己的私房钱($5000000)
# 继承给徒弟，这时就要为钱这个属性设置私有权限。

"""
封装简介：
    概述：属于面向对象三大特征之一，就是隐藏对象的属性和方法细节，仅对外提供公共访问方式
怎么封装&格式？
    属性：__属性
    方法： __方法名()
为什么要封装：
    1：提供代码的安全性   私有化来保障
    2：提高代码复用性     由函数来保障
弊端：代码量增加（公共访问接口），因为私有内容外界想访问，必须提供公共的接口。代码量增加了
"""


class Master:
    def __init__(self):
        self.kongfu = "[古法煎饼果子配方]"

    def make_cake(self):
        print(f"Master：运用{self.kongfu}制作煎饼果子")


class School:
    def __init__(self):
        self.kongfu = "[黑马AI煎饼果子配方]"

    def make_cake(self):
        print(f"School：运用{self.kongfu}制作煎饼果子")
class Prentice(School, Master):
    # 创新
    def __init__(self):
        self.kongfu = "[独创的煎饼果子配方]"
        self.__money = 20000  # 有钱

    def __make_cake(self):
        print(f"Prentice：运用{self.kongfu}制作煎饼果子")

    # 我需要时不时给tusun展示一下我的实力
    def get_money(self):
        return self.__money

    def set_money(self,money):
        self.__money=money
class TuSun(Prentice):
    pass
# ts = TuSun()
# print(ts.kongfu)
# ts.make_cake()
# # print(ts.money)  # 这里已经将师傅的钱私有了。即tusun拿不到money这个属性了
# # AttributeError: 'TuSun' object has no attribute 'money'
# print(ts.get_money())  # 师傅对外提供的访问接口。只能通过这个接口来访问
# ts.set_money(10000)
# print(ts.get_money())
#
# #建议你私有化属性后，给属性提供公共访问接口 按照 getxxx setxxxx


#测试私有化方法
ts = TuSun()
print(ts.make_cake())
```

## 多态入门

```python
# 定义动物类
class Animal:
    def speak(self):  # 叫抽象的、
        print("叫一声")


class Dog(Animal):
    def speak(self):
        print("狗:汪汪叫")


class Cat(Animal):
    def speak(self):
        print("猫：喵喵叫")


def make_noise(an: Animal):
    an.speak()


make_noise(Dog())
make_noise(Cat())

print(1)
print("str")

#
# #简单
# d = Dog()
# # d.speak()
# c  = Cat()
# # c.speak()
# #演示多态
# # make_noise(d)
# # make_noise(c)
#
# #父类引用指向子类对象
# an:Animal=Dog()   #
# an.speak()
#
# an:Animal=Cat()   #
# an.speak()
#
# # #父类引用指向父类对象
# # an:Animal=Animal()
# # an.speak()
#

```

## 多态案例_构建对战平台

![1741924352691](1741924352691.png)

```python
# 构建对象对战平台object_play
# 1 英雄一代战机（战斗力60）与敌军战机（战斗力70）对抗。
# 英雄1代战机失败！
# 2 卧薪尝胆，英雄二代战机（战斗力80）出场！，战胜敌军战机！
# 3 对象对战平台object_play, 代码不发生变化的情况下, 完成多次战斗
"""
概述：
    专业版：同一个函数，接受不同的参数，有不同的效果
    大白话：同一个事务在不同的时刻中表现出不同的状态
python中多态：前提条件
    1：要有继承
    2：要有方法重写
    3：父类引用指向子类对象
"""


class HeroFighter:
    def power(self):
        return 60


class EnemyFighter:
    def power(self):
        return 70


class TwoHeroFighter(HeroFighter):
    def power(self):
        return 80


# 注意缩进：  构建对战平台， 公共的函数，接受不同的参数
def obejct_play(hero:HeroFighter, enemy):
    if hero.power() >= enemy.power():
        print("英雄机赢了")
    else:
        print("英雄机 惜败")


h1 = HeroFighter()
e1 = EnemyFighter()
h2=TwoHeroFighter()
obejct_play(h1,e1)
obejct_play(h2,e1)



```

## 抽象类案例_空调案例

```python
"""
抽象类（接口） 一般充当父类，是一种标准（行业标准）
    抽象类：包含有抽象方法的类称之为抽象类
    抽象方法：方法体是空实现（pass）
"""


# 抽象类
class AC:
    def cool_wind(self):
        pass

    def hot_wind(self):
        pass

    def wind_l_r(self):
        pass

#实现父类（AC）中所有抽向方法
class Haier(AC):
    def cool_wind(self):
        print("吹冷风")

    def hot_wind(self):
        print("吹热风")

    # def wind_l_r(self):
    #     print("摆头吹")


class Gree(AC):
    def cool_wind(self):
        print("吹冷风")

    def hot_wind(self):
        print("吹热风")

    def wind_l_r(self):
        print("摆头吹")


h = Haier()
h.cool_wind()
h.hot_wind()
# h.wind_l_r()

g=Gree()
g.cool_wind()
g.hot_wind()
g.wind_l_r()

```

## 对象属性和类型属性解释

* 图解

  ![1741935509782](1741935509782.png)

* 代码演示

  ```python
  """
  属性介绍：
          概述：
              他是一个用来描述事物特征，他是名字
          分类：
              对象属性：属于每个对象，即：每个对象的属性值可能不同.
              类属性：属于类的，即：能被该类下所有的对象所共享
          对象属性：
              定义到 init魔法方法的属性。每个对象都有自己的内容
              只能通过对象名.的方式调用
          类属性：
              定义到类中，函数外的属性（变量），能被该类下所有的对象所共享
              既能通过 类名. 还能通过 对象名. 的方式来调用，推荐 类名.方式
  """
  
  
  class Student:
      # 类属性    ：类中函数外
      teacher_name = "张老师"
  
      # 定义对象属性  即：定义到 init魔法方法的属性
      def __init__(self, name):
          self.name = name
  
      def __str__(self):
          return f"姓名{self.name}"
  
  
  s1 = Student("孔老师")
  print(s1)
  
  s2 = Student("王老师")
  print(s2)
  # 类属性   类名.属性
  print(Student.teacher_name)
  # 共享
  print(s1.teacher_name)
  print(s2.teacher_name)
  
  # 改类属性
  Student.teacher_name = "胡老师"
  print(s1.teacher_name)
  print(s2.teacher_name)
  print(Student.teacher_name)
  ```

## 类方法和静态方法

  ```python
"""
类方法：
    属于类的方法，可以通过 类名.方式进行调用   还可以通过 对象名.方式
    定义类方法的时候，必须使用装饰器@classmethod ,且第一个参数必须类对象
静态方法：
    属于该类的所有对象所共享的方法，可以通过类名.方式  还可以通过 对象名.方式
    定义静态方法的时候，必须使用装饰器 @staticmethod，且参数传不传都可以
区别：
    1：类方法第一个参数必须是类对象，静态方法对参数无特殊要求
    2：理解为：如果函数中要用到我们的类对象 ，就定义为类方法 ，否则定义为静态方法。
"""
#第一步：定义一个类
class Student:
    #第二步：类属性
    school="黑马"

    @classmethod
    def show1(cls):
        print("aaa")
        print(cls.school)
        print("我是类方法")

    @staticmethod
    def show2():
        print(Student.school)
        print("我是静态方法")

s1 = Student()
# s1.show1()

# s1.show2("a")





  ```

## 学生管理系统_学生类代码编写

> 如下是写到  **student.py** 文件中的代码

```python
"""
该文件用于记录学生类 ，学生属性信息有姓名、性别、年龄、联系方式、描述信息等；
"""
class Student:
    """
        对象属性 ：__init__方法中
    """
    def __init__(self, name, gender, age, phone, desc):
        self.name = name
        self.gender = gender
        self.age = age
        self.phone = phone
        self.desc = desc

    # 可以使用魔法方法进行统一格式输出
    def __str__(self):
        return f"姓名：{self.name},性别{self.gender},年龄{self.age},手机号{self.phone},描述信息{self.desc}"

# if __name__ == '__main__':
s1=Student("张三","男",20,"12343242342","这是一个好人")

# print(f"我是测试案例{s1}")

# main  回车键
#
if __name__ == '__main__':
    s1 = Student("张三", "男", 20, "12343242342", "这是一个好人")
#
#



```

## 学生管理系统_框架搭建

> 如下是写到 **studentcms.py** 文件中的内容.

```python
"""
该类的作用就是完成学生管理操作 ：即增删改查
"""
class StudentCMS:
    #实现功能（定义方法）
    @staticmethod
    def show_view():
        print("*"*24)
        print("学生管理系统V2.0面向对象版本")
        print("1.添加学生信息")
        print("2.修改学生信息")
        print("3.删除学生信息")
        print("4.查询某个学生信息")
        print("5.显示所有学生信息")
        print("6.保存学生信息")
        print("0.退出系统")
        print("*" * 24)

    def add_student(self):
        print("add_student")

    def update_student(self):
        print("update_student")

    def del_student(self):
        print("del_student")

    def search_one_student(self):
        print("search_one_student")

    def search_all_student(self):
        print("search_all_student")

    def save_student(self):
        print("save_student")

    def exit_student(self):
        print("exit_student")

    def star(self):
        while True:
            StudentCMS.show_view()
            input_num =input("请您输入要操作编号")
            if input_num =="1":
                self.add_student()
            elif input_num =="2":
                self.update_student()
            elif input_num=="3":
                self.del_student()
            elif input_num =="4":
                self.search_one_student()
            elif input_num=="5":
                self.search_all_student()
            elif input_num=="6":
                self.save_student()
            elif input_num=="0":
                self.exit_student()
            else:
                print("您输入的有误！！！")

if __name__ == '__main__':
    cms = StudentCMS()
    cms.star()




```

## 学生管理系统_入口文件

> 如下的代码是写到 **main.py** 文件中的.

```python
"""
该文件 作为整个程序的入口文件
"""

from studentcms import  StudentCMS

if __name__ == '__main__':
    #我只在这个main.py文件中创建对象
    stu_cms=StudentCMS()
    stu_cms.star()

```

## 学生管理系统_功能实现

* 添加学生

  ```python
  # 4. 定义函数, 实现添加学生信息功能.
  def add_student(self):
      # 4.1 提示用户输入学生信息, 并接收.
      name = input('请输入学生姓名:')
      gender = input('请输入学生性别:')
      age = int(input('请输入学生年龄:'))
      phone = input('请输入学生电话:')
      desc = input('请输入学生描述信息:')
      # 4.2 把上述的信息封装成学生对象.
      stu = Student(name, gender, age, phone, desc)
      # 4.3 把学生对象添加到列表中.
      self.stu_list.append(stu)
      # 4.4 提示.
      print(f'添加 {name} 学生信息成功!\n')
  ```

* 查看所有学生信息

  ```python
  # 8. 定义函数, 实现查询所有学生信息功能.
  def search_all_student(self):
      # 8.1 判断列表长度是否为0, 如果为0, 提示: 暂无学生信息, 请添加后查询.
      if len(self.stu_list) == 0:
          print('暂无学生信息, 请添加后查询! \n')
      else:
          # 8.2 如果长度不为0, 遍历列表, 打印出所有的学生信息.
          for stu in self.stu_list:
              print(stu)
          print()     # 为了格式好看, 加个换行.
  ```

* 删除学生信息

  ```python
  # 5. 定义函数, 实现删除学生信息功能.
  def del_student(self):
      # 5.1 提示用户输入要删除的学生的姓名, 并接收.
      del_name = input('请输入要删除的学生姓名:')
      # 5.2 遍历列表, 找到要删除的学生, 并删除.
      for stu in self.stu_list:
          # 5.3 如果当前学生的姓名 和 要删除的学生相同, 就删除该学生信息
          if stu.name == del_name:
              self.stu_list.remove(stu)
              print(f'学员 {del_name} 信息删除成功!\n')
              break
              else:
                  # 走到这里, 说明没有走break, 即: 没有找到这个学生.
                  print('查无此人, 请检查后重新删除!\n')
  ```

* 修改学生信息

  ```python
  # 6. 定义函数, 实现修改学生信息功能.
  def update_student(self):
      # 6.1 提示用户输入要修改的学生的姓名, 并接收.
      upd_name = input('请输入要修改的学生姓名:')
      # 6.2 遍历列表, 找到要修改的学生, 并修改.
      for stu in self.stu_list:
          # 6.3 如果当前学生的姓名 和 要修改的学生相同, 就修改该学生信息
          if stu.name == upd_name:
              # 6.4 提示用户录入该学员新的信息.
              stu.gender = input('请录入修改后的性别: ')
              stu.age = int(input('请录入修改后的年龄: '))
              stu.phone = input('请录入修改后的电话: ')
              stu.desc = input('请录入修改后的描述信息: ')
  
              print(f'学员 {upd_name} 信息修改成功!\n')
              break
              else:
                  # 走到这里, 说明没有走break, 即: 没有找到这个学生.
                  print('查无此人, 请检查后重新操作!\n')
  ```

* 查询单个学生信息

  ```python
  # 7. 定义函数, 实现查询单个学生信息功能.
  def search_one_student(self):
      # 7.1 提示用户输入要查找的学生的姓名, 并接收.
      search_name = input('请输入要查找的学生姓名:')
      # 7.2 遍历列表, 找到要查找的学生, 并打印信息.
      for stu in self.stu_list:
          # 7.3 如果当前学生的姓名 和 要查找的学生相同, 就打印该学生信息
          if stu.name == search_name:
              print(stu, end='\n\n')
              break
              else:
                  # 走到这里, 说明没有走break, 即: 没有找到这个学生.
                  print('查无此人, 请检查后重新操作!\n')
  ```

## 扩展_dict属性

```python
"""
__dict__属性介绍
    他是python内置的。可以把对象转换为字典
"""
from student import Student
#
# s1 =Student("周云杰","男",60,"421313214","海尔老总")
# s2 =Student("周云杰2","男",30,"421313214","海尔小总")
# s3 =Student("周云杰3","男",35,"421313214","海尔总总")
# stu_list=[s1,s2,s3]
#
# #列表推导式
# list_change_dict=[stu.__dict__ for stu in stu_list]
# print(list_change_dict)

#需求：字典转换为对象
my_dict ={'name': 'zhouyunjie', 'gender': '男', 'age': 30, 'phone': '43241421', 'desc': '海尔老总'}
s6=Student(**my_dict)
print(s6)
print(type(my_dict))
print(type(s6))





#
#
# print(s1)
# #想 {'name':'周云杰','gender':'男' ....}
# mydicts1=s1.__dict__
# print(mydicts1)
```

## 学生管理学系统_保存学生信息

```python
# 9. 定义函数, 实现保存学生信息功能.
def save_student(self):
    # 9.1 关联 学生信息文件.
    with open('./stu_data.txt', 'w', encoding='utf-8') as dest_f:
        # 9.2 把 [学生对象, 学生对象...] -> [字典, 字典...]
        stu_dict = [stu.__dict__ for stu in self.stu_list]
        # 9.3 把字典列表, 持久化到文件中.
        dest_f.write(str(stu_dict)) # 记得转成字符串再写入.
```

## 学生管理系统_加载学生信息

```python
# 10. 定义函数, 实现加载学生信息.
def load_student(self):
    # 10.1 加入异常处理, 有可能文件不存在.
    try:
        # 10.2 关联学生信息文件.
        with open('./stu_data.txt', 'r', encoding='utf-8') as src_f:
            # 10.3 一次性读取所有数据.
            stu_data = src_f.read()     # '[字典, 字典...]'
            # 10.4 把上述的字符串, 转为列表.
            stu_list = eval(stu_data)   # ''
            # 10.5 判断如果列表为空, 就赋予空列表.
            if len(stu_list) == 0:
                stu_list = []
                # 10.6 把stu_list(列表套字典) 转成 [学生对象, 学生对象...], 并赋值给 self.stu_list
                self.stu_list = [Student(**stu_dict) for stu_dict in stu_list]
                except:
                    # 10.7 走这里, 说明目的地文件不存在, 创建即可.
                    with open('./stu_data.txt', 'w', encoding='utf-8') as src_f:
                        pass
```

## 学生管理系统_最终代码

* **student.py** 文件中的代码

  ```python
  """
  该文件用于记录学生类 ，学生属性信息有姓名、性别、年龄、联系方式、描述信息等；
  """
  class Student:
      """
          对象属性 ：__init__方法中
      """
      def __init__(self, name, gender, age, phone, desc):
          self.name = name
          self.gender = gender
          self.age = age
          self.phone = phone
          self.desc = desc
  
      # 可以使用魔法方法进行统一格式输出
      def __str__(self):
          return f"姓名：{self.name},性别{self.gender},年龄{self.age},手机号{self.phone},描述信息{self.desc}"
  
  # if __name__ == '__main__':
  s1=Student("张三","男",20,"12343242342","这是一个好人")
  
  # print(f"我是测试案例{s1}")
  
  # main  回车键
  #
  if __name__ == '__main__':
      s1 = Student("张三", "男", 20, "12343242342", "这是一个好人")
  #
  #
  
  
  
  ```

* **studentcms.py** 文件中的代码

  ```python
  """
  该类的作用就是完成学生管理操作 ：即增删改查
  """
  
  # import  student as st
  from student import Student
  import os
  class StudentCMS:
      def __init__(self):
          self.stu_list = []  # 主要使用用于存储学生信息 [stu,stu,stu,stu]  面向对象
  
      # 实现功能（定义方法）
      @staticmethod
      def show_view():
          print("*" * 24)
          print("学生管理系统V2.0面向对象版本")
          print("1.添加学生信息")
          print("2.修改学生信息")
          print("3.删除学生信息")
          print("4.查询某个学生信息")
          print("5.显示所有学生信息")
          print("6.保存学生信息")
          print("7.加载学生信息")
          print("0.退出系统")
          print("*" * 24)
      def add_student(self):
          name = input("请输入学生姓名")
          gender = input("请输入学生性别")
          age = int(input("请输入学生年龄"))
          phone = input("请输入学生电话")
          desc = input("请输入学生描述")
          stu = Student(name, gender, age, phone, desc)
          self.stu_list.append(stu)
          print(f"添加{name}学生信息成功")
  
      def update_student(self):
          upd_name = input("请输入要修改学生姓名")
          for stu in self.stu_list:
              if stu.name == upd_name:
                  stu.gender = input("请输入您要修改的性别")
                  stu.age = input("请输入您要修改的年龄")
                  stu.phone = input("请输入您要修改的手机号")
                  stu.desc = input("请输入您要修改的描述信息")
                  print(f"学生{upd_name}信息修改成功")
                  break
          else:
              print("查无此人")
      def del_student(self):
          del_name = input("请输入您要删除学生姓名")
          for stu in self.stu_list:
              if stu.name == del_name:
                  self.stu_list.remove(stu)
                  print(f"学员{del_name}信息删除成功")
                  break
          else:
              print("查无此人")
  
      def search_one_student(self):
          search_name = input("请输入您要查找学生姓名:")
          for stu in self.stu_list:
              if stu.name == search_name:
                  print(stu)
                  break
          else:
              print("查无此人")
          # print("search_one_student")
  
      def search_all_student(self):
          if len(self.stu_list) == 0:
              print("暂无学生信息")
          else:
              for stu in self.stu_list:
                  print(stu)
  
      def save_student(self):
          with open("./stu_data.txt","w",encoding="utf-8") as dets_f:
              stu_dict= [stu.__dict__ for stu in self.stu_list]
              # for stu in self.stu_list:
              #     dets_f.write(str(stu))
              dets_f.write(str(stu_dict))
  
      def exit_student(self):
          os._exit(0)
  
      # 加载.txt文本文件中的学生信息
      # 读文件
      # 遍历将文件内容加载列表中
      def load_student(self):
          try:  #万一没有文件呢！！！
              with open("./stu_data.txt","r",encoding="utf-8") as src_f:
                  stu_data=src_f.read()  #[字典,字典,字典]
                  #把里面的字符串，根据字符串特点，推断合适格式
                  stu_list=eval(stu_data)
                  if len(stu_list)==0:
                      stu_list=[]
                  #把列表套字典转换为[学生对象,学生对象,学生对象...] 赋值 self.stu_list
                  self.stu_list=[Student(**stu_dict) for stu_dict in stu_list]
          except:
              with open("./stu_data.txt","w",encoding="utf-8") as src_f:
                  pass
  
      def star(self):
          while True:
              StudentCMS.show_view()
              input_num = input("请您输入要操作编号")
              if input_num == "1":
                  self.add_student()
              elif input_num == "2":
                  self.update_student()
              elif input_num == "3":
                  self.del_student()
              elif input_num == "4":
                  self.search_one_student()
              elif input_num == "5":
                  self.search_all_student()
              elif input_num == "6":
                  self.save_student()
              elif input_num == "7":
                  self.load_student()
              elif input_num == "0":
                  self.exit_student()
              else:
                  print("您输入的有误！！！")
  
  
  if __name__ == '__main__':
      cms = StudentCMS()
      cms.star()
  
  ```

* **main.py** 文件中的代码

  ```python
  """
  该文件 作为整个程序的入口文件
  """
  
  from studentcms import  StudentCMS
  
  if __name__ == '__main__':
      #我只在这个main.py文件中创建对象
      stu_cms=StudentCMS()
      stu_cms.star()
  
  ```
