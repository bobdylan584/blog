---
title: 面向对象基础
date: 2023-06-03 03:44:51
tag: Python Advanced
---

## 面向对象和面向过程

* 编程思想

  > 就是人们利用计算机来解决问题的思维.

* 分类

  * 面向过程

    > 它是一种编程思想, 强调的是以 步骤(过程) 为基础完成各种操作.

  * 面向对象

    > **参考思路:** 概述, 思想特点, 举例, 总结
    >
    > 它是一种编程思想, 强调的是以 **对象** 为基础完成各种操作, 它是基于 面向过程的. 
    > 说到面向对象, 不得不提的就是它的三大思想特点:
    >
    >  	1. 更符合人们的思考习惯.
    >  	2.  把复杂的事情简单化.
    >  	3. 把人们(程序员)从执行者变成指挥者.
    >
    > 举例: 越符合当时的场景越好, 例如: 买电脑, 洗衣服...
    >
    > 总结: 万物接对象.

## 面向对象特征介绍

* 三大特征

  * 封装
  * 继承
  * 多态

* 封装简介

  * 概述

    > 就是隐藏对象的属性和实现细节, 仅对外提供公共的访问方式. 

  * 举例

    * 电脑, 手机, 函数, 类 = 属性 + 行为

  * 好处

    > 提高代码的安全性.     (私有化)
    >
    > 提高代码的复用性.      (函数)

* 继承

  * 概述

    > 子类继承父类的成员, 例如: 属性, 行为等.  
    > 大白话: 子承父业. 

  * 好处

    > 提高代码的复用性. 

* 多态

  * 概述

    > 大白话： 同一个事物在不同时刻表现出来的不同状态, 形态.
    >
    > 专业版： 同1个函数， 接收不同的对象， 有不同的效果。 

## 入门案例_汽车类

```python
"""
1：面向对象概念：
    类：抽象的概念 ，看不见 、摸不着
    类=属性（生活：名词  编程：变量）+方法（生活：动词（行为） 编程：函数）
    对象：类的具体体现   类的实现（实例化一个类）
    属性：用来描述事物的特征（高矮胖瘦....）
        和之前定义变量一样
    行为：用来描述事物能干什么  吃、喝、睡
        和之前定义函数一样
2：类的格式
    class 类名:
       属性+方法
3：对象： 通过汽车图纸生产出来其他（即对象）
    3-1：对象语法格式
        定义：对象名 = 类()
        调用： 对象名.方法名()
"""


class Car:
    # 当前无属性
    # 当前有方法 函数  def 函数名(有参、无参):
    def run(self):
        print("我跑起来了")


# 1：创建一个汽车类对象
# 定义：对象名 = 类()
c1 = Car()

# 2：调用对象调用
# 对象名.方法名()
c1.run()


```

## self关键字介绍

* 案例1

  ```python
  """
  self关键字：
      概述：
          代表本类当前【对象】的引用，谁（哪个对象）调用，self就代表谁
      作用：
          用于实现函数【区分不同对象】
      总结：大白话
          1：如果你是C1对象，那么self值，代表C1，如果C2调用的话，self值就代表C2
          2：函数内部都一个self，哪个对象调用，我的self就代表谁
      同学问问题：
            张三的老师在给张三解决问题   李四的老师在给李四解决问题
      总结： 在类内   和 类外方法的调用
          1：在类内， 访问类中的行为（函数），通过self.的方式进行访问
          2：在类外 ，访问类中的行为（函数）,通过对象名.函数进行访问
  """
  
  
  # 1、类的定义
  class Car :
      # 属性 和行为
      def run(self):
          print(f"{self}跑起来了")
  
      def work(self):
          print(f"我是work函数，我的self值是:",{self})
      #我想在work里面调用run
          # run()  在类内访问类中的函数（行为）必须使用self.方式
          self.run()   # = 本类当前对象的引用
  
  
  # 2、类的调用
  c1 = Car()
  print(f"C1对象:", {c1})  # 0x000001BC70B8B640
  c1.run()                # 0x000001BC70B8B640
  print("*"*10)
  c1.work()
  
  # 3.定义一个新的对象
  print("-" * 24)
  c2 = Car()
  print(f"C2对象:", {c2})  # 0x000002B8B275B250
  c2.run()                # 0x000002B8B275B250
  
  # 4.小结：c1和c2打印的值不同 ，因为他们是不同的对象。self代表的c1 和c2
  #        当c1调用的时候self就代表c1   当c2调用的时候self就代表c2
  
  ```


## 入门案例_手机类

```python
"""
回顾：
    类定义格式
        class 类名:
            属性（变量）
            方法（函数）
    访问： 类中行为访问
        类内：self.
        类外：对象名.
"""


class Phone:

    # 行为=方法=函数
    def open(self):
        print(f"{self}手机开机了")


    def close(self):
        print(f"{self}手机关机了")

    def take_photo(self):
        print(f"{self}手机可以拍照了")

# 2、创建手机类的对象  =  实例化手机类对象  访问其成员（方法、属性）
#以为都是p1 ，因为对象都是一个
p1=Phone()
print(f"p1对象：",{p1})
p1.open()
p1.take_photo()
p1.close()
print("*"*24)

#3、继续创建手机对象
p2=Phone()
print(f"p2对象：",{p2})
p2.open()
p2.take_photo()
p2.close()
print("*"*24)

```

## 类外_获取和设置对象的属性

![1742590962905](1742590962905.png)

```python
"""
属性设置：
    【属性赋值】对象名.属性名=属性值
    【属性调用】 对象名.属性名

    类外 设置属性
        对象名.属性名=属性值
    特点：该属性独属于这个对象。即该类的其他对象没有这个属性

    类内 设置属性
        self.属性名=属性值
"""


class Car:
    def run(self):
        print("汽车会跑")

# 类外  创建该类的对象名  -》此位置 类外的位置
c1 = Car()
c1.run()
# 细节1：对C1设置属性值
c1.color = '红色'
c1.number = 4

# 细节2：打印C1的对象属性值
print(f"颜色：{c1.color},轮胎数:{c1.number}")

print("*" * 24)
# 定义其他对象
c2 = Car()
c2.run()
# c2调用属性
print(c2.color)
print(c2.number)
  # 分析：报错， c2尝试去color和number，因为c1设置是类外属性，仅仅对c1有效。c2找不到


```

## 类内_获取对象的属性

```python
"""
例如，在类内部定义一个show()方法来获取刚刚给车设置颜色为红色、4个轮胎的属性值信息。
"""


# 1：创建汽车类
class Car:

    def run(self):
        print("汽车会跑")

    def show(self):
        print(f"我是show函数，对象颜色是{self.color},对象轮胎数：{self.number}")


# 2:根据汽车类创建对象
c1 = Car()

# 3：给C1进行赋值  类外赋值
c1.color = "红色"
c1.number = 4

# 4:类外访问属性
print(f"颜色：{c1.color}，轮胎数{c1.number}")

# 5：类外访问行为（类中的函数）
c1.run()
c1.show()

# 6.继续创建汽车类的对象，尝试调用run和show函数
c2 = Car()
c2.run()
c2.show()  # 解释通过（car类内中有show方法），运行报错（show方法里面调用的属性，c2没有定义）

# 总结
# 1:【类外】访问类中的成员，无论是设置还是获取，都是通过  对象名.方法
# 2：【类内】访问类中的成员，无论是设置还是获取，都是通过 self.方法
# 3：如果类外设置属性，那么属性仅仅是当前的对象可以使用。如果想让所有的对象都可以使用，设置在类内？
#    如何设置 ？  采用魔法方法__init__

```

## 魔法方法之init方法

* 图解

  ![1742591021157](1742591021157.png)

* 案例1: 无参数版

  ```python
  """
  魔法方法：
      Python内置函数，在满足特点的场景下，会被自动调用
  场景魔法方法：
      __init__   在（每次）创建对象的时候，会自动触发该类__init__()函数
      __str__
      __del__
  """
  
  
  # 给车这个对象默认设置color(颜色)和number(轮胎数)为黑色、3个轮胎。
  #1.定义类
  class Car:
      # 函数 、方法、 行为
      def __init__(self):
          print("我是无参init魔法方法")
          self.color='黑色'
          self.number=3
      def show(self):
          print(f"颜色{self.color} , 轮胎数{self.number}")
  
  # 演示：就是每创建一次对象，调用一次init方法
  # 2.创建汽车类对象
  c1 = Car()
  # c1.__init__()
  c1.show()
  print("*" * 24)
  c2 = Car()
  #结论：在（每次）创建对象的时候，会自动触发该类__init__()函数
  
  #演示初始化车参数 （颜色   轮胎）
  # 调用
  print(c1.color,c1.number)
  #修改
  c2.show()
  print("*"*24)
  c2.color='蓝色'
  c2.number=4
  print(c2.color,c2.number)
  c2.show()
  
  
  ```

* 案例2: 有参数版

  ```python
  """
  回顾：
      __init__()魔法方法，在创建对象的时候，会被自动调用。一般用于给该类的属性做初始化
      初始化：
          有参数初始化：
  """
  # 1、创建汽车类，并且初始化带参的方法。
  class Car:
      # 初始化带参数
      def __init__(self, color, number):
          self.color = color
          self.number = number
  
      def show(self):
          print(f"颜色{self.color} 轮胎数：{self.number}")
  
  # 2、实例化Car类的对象
  c1 = Car()  # __init__() missing 2 required positional arguments: 'color' and 'number'
  # c1 = Car("黄色",4)
  # 当带参数初始化方法出现的时候，即 在创建对象的时候。可以给对象予以初始化值，否则执行报错
  # c1.show()
  ```

## 魔法方法之str方法

```python
"""
魔法方法：
    Python内置函数，在满足特点的场景下，会被自动调用
场景魔法方法：
    __init__   在（每次）创建对象的时候，会自动触发该类__init__()函数
    __str__    当print()函数打印对象的时候，会自动调用该类（所在类）的str魔法方法
                当前方法默认打印的是对象的内存地址值，无意义，一般都会对方法进行重写改写。
                改写为打印各个属性值
    __del__
"""

# 例如，在输出car对象时，把它的颜色color和轮胎数number属性值显示出来。
#show 方法
class Car:
    def __init__(self,color,number):
        self.color=color
        self.number=number

    #如果没有讲str方法，我现在想打印属性值，该如何操作？
    def show(self):
        print(f"颜色{self.color}  轮胎数{self.number}")
    def __str__(self):
        return f"str重新改写后的显示格式:颜色{self.color}  轮胎数{self.number}"
#2.实例化对象
c1=Car("紫色",4)
# c1.show()
# print(c1)  #<__main__.Car object at 0x000001386961B640>
#这里其实走了__str__ 这个方法，因为我们没有对这个方法进行重写改写，所以这里打印的是地址值
#3.改写str魔法方法
print(c1) #此时已经重新写了str方法
```

## 魔法方法之del方法

```python
"""
魔法方法：
    Python内置函数，在满足特点的场景下，会被自动调用
场景魔法方法：
    __init__   在（每次）创建对象的时候，会自动触发该类__init__()函数
    __str__    当print()函数打印对象的时候，会自动调用该类（所在类）的str魔法方法
                当前方法默认打印的是对象的内存地址值，无意义，一般都会对方法进行重写改写。
                改写为打印各个属性值
    __del__     当.py文件执行结果后，或者手动del 释放对象资源的时候，会自动调用该函数
"""
# 例如，定义一个有品牌属性的汽车类，并使用__del__()方法删除对象查看效果。
class Car:
    # 2、在魔法方法init中完成属性初始化
    def __init__(self, brand):
        self.brand = brand

    # 3、重写改写str魔法方法 打印对象属性值
    def __str__(self):
        return f"品牌：{self.brand}"

    # 4、重写改写魔法删除方法 ，删除对象的时候给出提示
    def __del__(self):
        print(f"{self}对象被删除了")
# 5、创建汽车类对象
c1 = Car("小米")
# print(c1) #验证：str  #程序执行结束后自动删除

#6、演示手动删除
# del c1
print(c1)
print("程序结束")
```

## 减肥案例

```python
# 例如小明同学当前体重是100kg。每当他跑步一次时，
# # 则会减少0.5kg；每当他大吃大喝一次时，则会增加2kg。
# 请试着采用面向对象方式完成案例。
"""
类： 学生类
对象：小明
属性 ： 体重
行为：跑步 、大吃大喝
"""


# 1.类   同学
class Student:  # 大驼峰
    # 类=属性+方法（行为）
    # 2.当前体重是100kg
    def __init__(self,name):
        self.name  =name
        self.current_weigth = 100

    # 3、行为：跑步 、大吃大喝
    def run(self):
        print("疯狂跑步....")
        self.current_weigth -= 0.5

    def eat(self):
        print("大吃一顿")
        self.current_weigth += 2

    def __str__(self):
        return f"{self.name}当前体重{self.current_weigth}"
# 4、实例化学生对象
xm = Student("小明")
xm.run()
xm.eat()
print(xm)

```

## 烤地瓜案例

![1742591192478](1742591192478.png)

```python
"""
类：地瓜类
属性：烤的时间、烤的状态、调料
行为：烤、添加调料
"""


# SweetPotato 地瓜
class SweetPotato:
    # 类=属性+行为
    # 初始化地瓜都是生的  属性
    def __init__(self):
        self.cook_time = 0
        self.cook_state = '生的'
        self.seasoning = []  # 添加调料

    # 烤
    def cook(self, time):
        if time < 0:
            print("无效值！")
        else:
            self.cook_time += time  # 假设time传递的时间为2，即这个语句 0+2，相当于2分钟，如果再传5分钟  2+5 =7 熟了
            if 0 <= self.cook_time < 3:
                self.cook_state = "生的"
            elif 3 <= self.cook_time < 7:
                self.cook_state = "半生不熟"
            elif 7 <= self.cook_time < 12:
                self.cook_state = "熟了"
            else:
                self.cook_state = "糊了！！！"

    # 添加调料
    def addSeasoning(self, seasoning):
        # self.seasoning = seasoning
        self.seasoning.append(seasoning)

    def __str__(self):  # 格式化代码 ctrl+a 全选     ctrl+alt+l
        return f"烤的时间{self.cook_time} ,地瓜状态{self.cook_state},调料{self.seasoning}"


# 实例化对象
sp = SweetPotato()
#初始化地瓜状态
print(sp.cook_time)
print(sp.cook_state)
print(sp.seasoning)

#
sp.cook(2)
print(sp)
sp.cook(5)
print(sp)
sp.addSeasoning("玛莎拉")
sp.addSeasoning("胡椒")
sp.addSeasoning("辣椒")
print(sp)
```

## 创建类的格式

```python
"""
1:在python中，创建类有如下几种方式

    格式1:
            class 类名:
    格式2:
            class 类名():
    格式3:
            class 类名(object)
"""


# 需求 定义老师类
class Teacher(object):  # object是所有类的父类，python中所有的类都直接或者间接的继承object类
    pass

```

## 继承入门

```python
"""
在python中继承格式：
        class 父类名称(object):
            pass
        class 子类名称(父类名称):
            pass
    提示：object是所有类的父类 object类顶级类或者基类   ，其他的子类派生类

    好处：提高了代码复用性
    弊端：耦合性，父类有不好的内容，子类想没有都不行    高内聚，低耦合
    大白话：自己能搞定的事情，不要麻烦别人


例如，Father类有一个默认性别为男，且爱好散步行走，那么，Son类也想要拥有这些属性和行为，该怎么做呢？
"""


# 1、定义父类
class Father(object):
    def __init__(self):
        self.gender = "男"

    def walk(self):
        print("饭后走一走，活到九十九")
# 2、定义子类
class Son(Father):
    pass
# 3、测试儿子类
s1 = Son()
print(s1.gender)  # 打印男 ，继承自父类
s1.walk()  # 饭后走一走，活到九十九  继承自父类

```

## 单继承演示

```python
# 一个摊煎饼的老师傅，在煎饼果子界摸爬滚打多年，
# 研发了一套精湛的摊煎饼技术，
# 师父要把这套技术传授给他的唯一的最得意的徒弟。

# 老师傅
class Master:
    def __init__(self):
        self.kongfu = '[古法配方]'

    def make_cake(self):
        print(f"采用{self.kongfu}摊煎饼果子")
# Apprentice   徒弟
class Apprentice(Master):
    pass

# 测试  实例化徒弟类
app = Apprentice()
app.make_cake()

```



